# INPUTS:
#
# xx = c(x1, x2)
# a = constant (optional), with default value 1
# b = constant (optional), with default value 5.1/(4*pi^2)
# c = constant (optional), with default value 5/pi
# r = constant (optional), with default value 6
# s = constant (optional), with default value 10
# t = constant (optional), with default value 1/(8*pi)
#
##########################################################################
x1 <- xx[1]
x2 <- xx[2]
term1 <- a * (x2 - b*x1^2 + c*x1 - r)^2
term2 <- s*(1-t)*cos(x1)
y <- term1 + term2 + s
return(y)
}
branin(xx)
eggholder.pso = function(x)
-(x[,2]+47)*sin(sqrt(abs(x[,2]+x[,1]/2+47)))-x[,1]*sin(sqrt(abs(x[,1]-(x[,2]+47))))
eggholder.pso(x)
egg <- function(xx)
{
##########################################################################
#
# EGGHOLDER FUNCTION
#
# Authors: Sonja Surjanovic, Simon Fraser University
#          Derek Bingham, Simon Fraser University
# Questions/Comments: Please email Derek Bingham at dbingham@stat.sfu.ca.
#
# Copyright 2013. Derek Bingham, Simon Fraser University.
#
# THERE IS NO WARRANTY, EXPRESS OR IMPLIED. WE DO NOT ASSUME ANY LIABILITY
# FOR THE USE OF THIS SOFTWARE.  If software is modified to produce
# derivative works, such modified software should be clearly marked.
# Additionally, this program is free software; you can redistribute it
# and/or modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation; version 2.0 of the License.
# Accordingly, this program is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty
# of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# For function details and reference information, see:
# http://www.sfu.ca/~ssurjano/
#
##########################################################################
#
# INPUT:
#
# xx = c(x1, x2)
#
##########################################################################
x1 <- xx[1]
x2 <- xx[2]
term1 <- -(x2+47) * sin(sqrt(abs(x2+x1/2+47)))
term2 <- -x1 * sin(sqrt(abs(x1-(x2+47))))
y <- term1 + term2
return(y)
}
eggholder(xx)
egg(xx)
six.hump.camel.pso <- function(x)
(4-2.1*x[,1]^2+(x[,1]^4)/3)*x[,1]^2+x[,1]*x[,2]+(-4+4*x[,2]^2)*x[,2]^2
cross_in_tray = function(x,y)
(-0.0001*(abs(sin(x)*sin(y)exp(abs(100-((sqrt(x^2+y^2))/pi))))+1)^0.1)
gramacy_lee = function(x)
(((sin(10*pi*x))/(2*x))+(x-1)^4)
gramacy_lee = function(x)
(((sin(10*pi*x))/(2*x))+(x-1)^4)
gramacy_lee(6)
grlee12 <- function(x)
{
##########################################################################
#
# GRAMACY & LEE (2012) FUNCTION
#
# Authors: Sonja Surjanovic, Simon Fraser University
#          Derek Bingham, Simon Fraser University
# Questions/Comments: Please email Derek Bingham at dbingham@stat.sfu.ca.
#
# Copyright 2013. Derek Bingham, Simon Fraser University.
#
# THERE IS NO WARRANTY, EXPRESS OR IMPLIED. WE DO NOT ASSUME ANY LIABILITY
# FOR THE USE OF THIS SOFTWARE.  If software is modified to produce
# derivative works, such modified software should be clearly marked.
# Additionally, this program is free software; you can redistribute it
# and/or modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation; version 2.0 of the License.
# Accordingly, this program is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty
# of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# For function details and reference information, see:
# http://www.sfu.ca/~ssurjano/
#
##########################################################################
term1 <- sin(10*pi*x) / (2*x)
term2 <- (x-1)^4
y <- term1 + term2
return(y)
}
grlee12(6)
drop_wave = function(x,y)
(-(1+cos(12*sqrt(x^2+y^2)))/(0.5*(x^2+y^2)+2))
drop_wave(5,4)
drop <- function(xx)
{
##########################################################################
#
# DROP-WAVE FUNCTION
#
# Authors: Sonja Surjanovic, Simon Fraser University
#          Derek Bingham, Simon Fraser University
# Questions/Comments: Please email Derek Bingham at dbingham@stat.sfu.ca.
#
# Copyright 2013. Derek Bingham, Simon Fraser University.
#
# THERE IS NO WARRANTY, EXPRESS OR IMPLIED. WE DO NOT ASSUME ANY LIABILITY
# FOR THE USE OF THIS SOFTWARE.  If software is modified to produce
# derivative works, such modified software should be clearly marked.
# Additionally, this program is free software; you can redistribute it
# and/or modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation; version 2.0 of the License.
# Accordingly, this program is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty
# of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# For function details and reference information, see:
# http://www.sfu.ca/~ssurjano/
#
##########################################################################
#
# INPUT:
#
# xx = c(x1, x2)
#
##########################################################################
x1 <- xx[1]
x2 <- xx[2]
frac1 <- 1 + cos(12*sqrt(x1^2+x2^2))
frac2 <- 0.5*(x1^2+x2^2) + 2
y <- -frac1/frac2
return(y)
}
drop(5,4)
drop(x)
test_tube_1 = function(x,y)
-4*abs(sin(x)*cos(y)*exp(1)^abs(cos(((x^2)+(y^2))/200)))
test_tube(9,3)
test_tube_1(9,3)
mccormick = function(x,y)
sin(x+y)+(x-y)^2-(1.5*x)+(2.5*y)+1
mccormick(5,4)
mccormick = function(x)
sin(x[,1]+x[,2])+(x[,1]-x[,2])^2-(1.5*x[,1])+(2.5*x[,2])+1
mccormick(x)
mccorm <- function(xx)
{
##########################################################################
#
# MCCORMICK FUNCTION
#
# Authors: Sonja Surjanovic, Simon Fraser University
#          Derek Bingham, Simon Fraser University
# Questions/Comments: Please email Derek Bingham at dbingham@stat.sfu.ca.
#
# Copyright 2013. Derek Bingham, Simon Fraser University.
#
# THERE IS NO WARRANTY, EXPRESS OR IMPLIED. WE DO NOT ASSUME ANY LIABILITY
# FOR THE USE OF THIS SOFTWARE.  If software is modified to produce
# derivative works, such modified software should be clearly marked.
# Additionally, this program is free software; you can redistribute it
# and/or modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation; version 2.0 of the License.
# Accordingly, this program is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty
# of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# For function details and reference information, see:
# http://www.sfu.ca/~ssurjano/
#
##########################################################################
#
# INPUT:
#
# xx = c(x1, x2)
#
##########################################################################
x1 <- xx[1]
x2 <- xx[2]
term1 <- sin(x1 + x2)
term2 <-(x1 - x2)^2
term3 <- -1.5*x1
term4 <- 2.5*x2
y <- term1 + term2 + term3 + term4 + 1
return(y)
}
mccorm(xx)
holder.table.pso <- function(x)
-abs(sin(x[,1])*cos(x[,2])*exp(abs(1 - sqrt(x[,1]^2+x[,2]^2)/pi)))
holder.table.pso(x)
cross_in_tray = function(x,y)
-0.0001*(abs(sin(x)*sin(y)*exp(abs(100-((sqrt(x^2+y^2))/pi))))+1)^0.1
cross_in_tray(5,4)
crossit <- function(xx)
{
##########################################################################
#
# CROSS-IN-TRAY FUNCTION
#
# Authors: Sonja Surjanovic, Simon Fraser University
#          Derek Bingham, Simon Fraser University
# Questions/Comments: Please email Derek Bingham at dbingham@stat.sfu.ca.
#
# Copyright 2013. Derek Bingham, Simon Fraser University.
#
# THERE IS NO WARRANTY, EXPRESS OR IMPLIED. WE DO NOT ASSUME ANY LIABILITY
# FOR THE USE OF THIS SOFTWARE.  If software is modified to produce
# derivative works, such modified software should be clearly marked.
# Additionally, this program is free software; you can redistribute it
# and/or modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation; version 2.0 of the License.
# Accordingly, this program is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty
# of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# For function details and reference information, see:
# http://www.sfu.ca/~ssurjano/
#
##########################################################################
#
# INPUT:
#
# xx = c(x1, x2)
#
##########################################################################
x1 <- xx[1]
x2 <- xx[2]
fact1 <- sin(x1)*sin(x2)
fact2 <- exp(abs(100 - sqrt(x1^2+x2^2)/pi))
y <- -0.0001 * (abs(fact1*fact2)+1)^0.1
return(y)
}
crossit(xx)
psoptim <- function(FUN, n=100, max.loop=100, w=.9, c1=.2, c2=.2, xmin, xmax, vmax=c(4,4), seed=10, anim=TRUE)
{
#FUN - nazwa optymalizowanej funkcji, funkcja musi byc jednoargumentowa
#co oznacza ze argumentem jest wektor
# n - liczba czastek w roju
# max.loop - maksymalna liczba iteracji
# w - wspolczynnik bezwladnosci
# c1 - wspolczynnik wlasnego "zaufania"
# c2 - wspolczynnik "zaufania" do roju
# xmin - wektor okreslajacy dolne ograniczenia wartosci zmiennych
# xmax - wektor okreslajacy gorne ograniczenia wartosci zmiennych
# vmax - wektor ograniczen predkosci w kazdym kierunku
# seed - liczba naturalna okreslajaca tzw. ziarno dla generatora liczb
#pseudolosowych argument stosowany w celu uzyskania powtarzalnosci otrzymywanych wynikow
# anim - wartosc logiczna, jesli prawda TRUE(wartosc domyslna), to animacja przebiegu
# optymalizajci jest wlaczona
g1 <- function(x,y)
{
FUN(cbind(x,y))
}
d <- length(xmin)
set.seed(seed)
x <- matrix(nrow=n, ncol=d)
for(i in 1:d)
x[,i] <- runif(n, xmin[1],xmax[1])
wart.f <- FUN(x)
x.best.czastki <- x
x.best.roju <- matrix(x[which.max(wart.f),], ncol=d)
if((d == 2) && anim)
{
x_image <- matrix(c(seq(from=xmin[1],to=xmax[1],length.out=100),seq(from=xmin[2],to=xmax[2],length.out=100)), ncol=2)
z <- outer(x_image[,1], x_image[,2], g1)
image(x_image[,1], x_image[,2], z, xlab="x1", ylab="x2", main="Initial swarm")
contour(x_image[,1], x_image[,2], z, nlevels=10, add=TRUE, col="grey50")
points(x[,1], x[,2], pch=19, col="darkslateblue")
}
if (interactive() && anim && (d==2)) {
invisible(readline(prompt = "Press <Enter>/<Return> to continue..."))
}
v <- matrix(runif(n*d, min=-vmax, max=vmax), ncol=d, nrow=n)
g.mean <- c()
g.best <- c()
loop <- 1
while(loop <= max.loop)
{
wart.f <- FUN(x)
g.mean <- rbind(g.mean, mean(wart.f))
idx <- which(wart.f > FUN(x.best.czastki))
x.best.czastki[idx,] <- x[idx,]
x.best.roju.nowe <- matrix(x[which.max(FUN(x.best.czastki)),],ncol=d)
if(FUN(x.best.roju.nowe) > FUN(x.best.roju))
x.best.roju <- x.best.roju.nowe
g.best <- rbind(g.best, FUN(x.best.roju))
for(i in 1:n)
{
for(j in 1:d)
{
r1 <- runif(1)
r2 <- runif(1)
v[i,j] <- w*v[i,j] + c1*r1*(x.best.czastki[i,j] - x[i,j]) +  c2*r2*(x.best.roju[j]-x[i,j])
if(v[i,j] > vmax[j] || v[i,j] < -vmax[j])
v[i,j] <- vmax[j]
x_prev <- x[i,j]
x[i,j] <- x[i,j] + v[i,j]
if(x[i,j] > xmax[j])
x[i,j] <- x_prev
if(x[i,j] < xmin[j])
x[i,j] <- x_prev
}
}
if((d==2) && anim)
{
contour(x_image[,1], x_image[,2], z, nlevels=20, xlab="x1", ylab="x2", col="darkgray", main=paste(loop, "/", max.loop))
points(x, xlim=c(xmin[1], xmax[1]), ylim=c(xmin[2], xmax[2]), pch=21, bg="cadetblue")
# points(x, xlim=c(xmin[1], xmax[1]), ylim=c(xmin[2], xmax[2]), pch=21, bg=densCols(x))
}
loop <- loop + 1
}
if(anim)
{
if (interactive() & (d==2)) {
invisible(readline(prompt = "Press <Enter>/<Return> to continue..."))
}
}
plot(g.best, type="o", col="darkgreen", pch=19, cex=.7, ylim=c(min(g.mean),max(g.best)), xlab="Iteration", ylab="Fitness value")
lines(g.mean, type="o", col="blue", cex=.7, pch=19)
legend("bottomright", legend = c("Best", "Mean"), col = c("darkgreen", "blue"), pch = 19, lty = 1, merge = TRUE)
colnames(x.best.roju) <- paste("x", seq(1:d), sep="")
res <- list(sol = x.best.roju, val=g.best[loop-1])
return(res)
}
n <- 50
m.l <- 50
w <- 0.95
c1 <- 0.2
c2 <- 0.2
xmin <- c(-32, -32)
xmax <- c(32, 32)
vmax <- c(4, 4)
start.time <- Sys.time()#czas trzeba mierzyc z anim=FALSE
psoptim(FUN=cross_in_tray, n=n, max.loop=m.l, w=w, c1=c1, c2=c2,
xmin=xmin, xmax=xmax, vmax=vmax, seed=5)
endtime <- Sys.time()
time.taken <- endtime - start.time
time.taken
cross_in_tray = function(x) # x[-10,10]
-0.0001*(abs(sin(x[,1])*sin(x[,2])*exp(abs(100-((sqrt(x[,1]^2+x[,2]^2))/pi))))+1)^0.1
n <- 50
m.l <- 50
w <- 0.95
c1 <- 0.2
c2 <- 0.2
xmin <- c(-32, -32)
xmax <- c(32, 32)
vmax <- c(4, 4)
start.time <- Sys.time()#czas trzeba mierzyc z anim=FALSE
psoptim(FUN=cross_in_tray, n=n, max.loop=m.l, w=w, c1=c1, c2=c2,
xmin=xmin, xmax=xmax, vmax=vmax, seed=5)
time.taken <- endtime - start.time
time.taken
n <- 50
m.l <- 50
w <- 0.95
c1 <- 0.2
c2 <- 0.2
xmin <- c(-10, -10)
xmax <- c(10, 10)
vmax <- c(4, 4)
start.time <- Sys.time()#czas trzeba mierzyc z anim=FALSE
psoptim(FUN=cross_in_tray, n=n, max.loop=m.l, w=w, c1=c1, c2=c2,
xmin=xmin, xmax=xmax, vmax=vmax, seed=5)
time.taken <- endtime - start.time
time.taken
cross_in_tray = function(x) # x[-10,10]
-(-0.0001*(abs(sin(x[,1])*sin(x[,2])*exp(abs(100-((sqrt(x[,1]^2+x[,2]^2))/pi))))+1)^0.1)
cross_in_tray = function(x) # x[-10,10]
-(-0.0001*(abs(sin(x[,1])*sin(x[,2])*exp(abs(100-((sqrt(x[,1]^2+x[,2]^2))/pi))))+1)^0.1)
n <- 50
m.l <- 50
w <- 0.95
c1 <- 0.2
c2 <- 0.2
xmin <- c(-10, -10)
xmax <- c(10, 10)
vmax <- c(4, 4)
start.time <- Sys.time()#czas trzeba mierzyc z anim=FALSE
psoptim(FUN=cross_in_tray, n=n, max.loop=m.l, w=w, c1=c1, c2=c2,
xmin=xmin, xmax=xmax, vmax=vmax, seed=5)
time.taken <- endtime - start.time
time.taken
holder.table.pso <- function(x) #x[-10,10]
-abs(sin(x[,1])*cos(x[,2])*exp(abs(1 - sqrt(x[,1]^2+x[,2]^2)/pi)))
holder.table.pso(x)
rastrigin.pso <- function(x) # x[-5.12,5.12] min 0
{
20 + x[,1]^2 + x[,2]^2 - 10*(cos(2*pi*x[,1]) + cos(2*pi*x[,2]))
}
x = matrix(0,,2)
x[1,1] = 5
x[1,2] = 4rastrigin.pso(x)
x = matrix(0,,2)
x[1,1] = 5
x[1,2] = 4
rastrigin.pso(x)
rastr <- function(xx)
{
##########################################################################
#
# RASTRIGIN FUNCTION
#
# Authors: Sonja Surjanovic, Simon Fraser University
#          Derek Bingham, Simon Fraser University
# Questions/Comments: Please email Derek Bingham at dbingham@stat.sfu.ca.
#
# Copyright 2013. Derek Bingham, Simon Fraser University.
#
# THERE IS NO WARRANTY, EXPRESS OR IMPLIED. WE DO NOT ASSUME ANY LIABILITY
# FOR THE USE OF THIS SOFTWARE.  If software is modified to produce
# derivative works, such modified software should be clearly marked.
# Additionally, this program is free software; you can redistribute it
# and/or modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation; version 2.0 of the License.
# Accordingly, this program is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty
# of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# For function details and reference information, see:
# http://www.sfu.ca/~ssurjano/
#
##########################################################################
#
# INPUT:
#
# xx = c(x1, x2, ..., xd)
#
##########################################################################
d <- length(xx)
sum <- sum(xx^2 - 10*cos(2*pi*xx))
y <- 10*d + sum
return(y)
}
xx = c(5,4)
rastr(xx)
Rastrigin.ga <- function(x1, x2) # x[-5.12,5.12] min 0
20 + x1^2 + x2^2 - 10*(cos(2*pi*x1) + cos(2*pi*x2))
Rastrigin.ga(x)
Rastrigin.ga(5,4)
adjiman.pso = function(x)
cos(x[,1])*sin(x[,2]) - (x[,1])/(x[,2]^2 +1)
x = matrix(0,,2)
x[1,1] = 2
x[1,2] = 0.10
adjiman.pso(x)
bartels.conn.pso = function(x) # [-500,500] min 1 at (0,0)
abs(x[,1]^2 + x[,2]^2 + x[,1]*x[,2])+abs(sin(x[,1]))+abs(cos(x[,2]))
x[1,1] = 0
x[1,2] = 0
bartels.conn.pso(0,0)
bartels.conn.pso(x)
brent.pso = function(x) #[-10,10] min 0 at (0,0)
(x[,1]+10)^2 + (x[,2]+10)^2 + exp(1)^(-x[,1]^2 - x[,2]^2)
brent.pso(x)
x[1,1] = -10
x[1,2] = -10
brent.pso(x)
leon.pso = function(x) # [-1.2,1.2] min 0 at (1,1)
100*(x[,2]-x[,1]^2)^2 + (1-x[,1])^2
x[1,1] = -1.2
x[1,2] = 1.2
leon.pso(x)
x[1,1] = 1
x[1,2] = 1
leon.pso(x)
x[1,1] = 0
x[1,2] = 0
brent.pso(x)
goldstein.ga = function(x1,x2) # [-2,2] min 3 at (0,-1)
(1+(x1+x2+1)^2 * (19-14*x1+3*x1^2 - 14*x2+6*x1*x2+3*x2^2))*(30+(2*x1-3*x2)^2 * (18-32*x1+12*x1^2 + 48*x2-36*x1*x2+27*x2^2))
goldstein.ga(5,4)
goldstein.pso = function(x) # [-2,2] min 3 at (0,-1)
(1+(x[,1]+x[,2]+1)^2 * (19-14*x[,1]+3*x[,1]^2 - 14*x[,2]+6*x[,1]*x[,2]+3*x[,2]^2))*(30+(2*x[,1]-3*x[,2])^2 * (18-32*x[,1]+12*x[,1]^2 + 48*x[,2]-36*x[,1]*x[,2]+27*x[,2]^2))
x[1,1] = 5
x[1,2] = 4
goldstein.pso(x)
goldstein.abc = function(x) # [-2,2] min 3 at (0,-1)
(1+(x[1]+x[2]+1)^2 * (19-14*x[1]+3*x[1]^2 - 14*x[2]+6*x[1]*x[2]+3*x[2]^2))*(30+(2*x[1]-3*x[2])^2 * (18-32*x[1]+12*x[1]^2 + 48*x[2]-36*x[1]*x[2]+27*x[2]^2))
goldstein.abc(5,4)
xx=c(5,4)
goldstein.abc(xx)
rastrigin.ga <- function(x) # x[-5.12,5.12] min 0
20 + x[1]^2 + x[2]^2 - 10*(cos(2*pi*x[1]) + cos(2*pi*x[2]))
rastrigin.abc <- function(x) # x[-5.12,5.12] min 0
20 + x[1]^2 + x[2]^2 - 10*(cos(2*pi*x[1]) + cos(2*pi*x[2]))
goldstein.abc(xx)
rastrigin.abc <- function(x) # x[-5.12,5.12] min 0
20 + x[1]^2 + x[2]^2 - 10*(cos(2*pi*x[1]) + cos(2*pi*x[2]))
rastrigin.abc(xx)
rastrigin.ga <- function(x1, x2) # x[-5.12,5.12] min 0
20 + x1^2 + x2^2 - 10*(cos(2*pi*x1) + cos(2*pi*x2))
rastrigin.ga(5,4)
