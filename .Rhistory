stepsize <- runif(1)*(nest[sample.int(n),]-nest[sample.int(n),])
return(nest*stepsize*k)
}
# Application of simple constraints
simple.bounds <- function(s, lb, ub) {
# Apply the lower bound
ns_tmp <- s
i <- ns_tmp<lb
ns_tmp[i] <- lb[i]
# Apply the upper bounds
j <- ns_tmp>ub
ns_tmp[j] = ub[j]
# Update this new move
return(ns_tmp)
}
# You can replace the following by your own functions
# A d-dimensional objective functions
fobj <- function(u) {
## d-dimensional sphere function sum_j=1^d (u_j-1)^2.
# with a minimum at (1,1, ...., 1);
return(sum((u-1)^2));
}
fobj = function(5)
ackley <- function(xx, a=20, b=0.2, c=2*pi)
{
##########################################################################
#
# ACKLEY FUNCTION
#
# Authors: Sonja Surjanovic, Simon Fraser University
#          Derek Bingham, Simon Fraser University
# Questions/Comments: Please email Derek Bingham at dbingham@stat.sfu.ca.
#
# Copyright 2013. Derek Bingham, Simon Fraser University.
#
# THERE IS NO WARRANTY, EXPRESS OR IMPLIED. WE DO NOT ASSUME ANY LIABILITY
# FOR THE USE OF THIS SOFTWARE.  If software is modified to produce
# derivative works, such modified software should be clearly marked.
# Additionally, this program is free software; you can redistribute it
# and/or modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation; version 2.0 of the License.
# Accordingly, this program is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty
# of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# For function details and reference information, see:
# http://www.sfu.ca/~ssurjano/
#
##########################################################################
#
# INPUTS:
#
# xx = c(x1, x2, ..., xd)
# a = constant (optional), with default value 20
# b = constant (optional), with default value 0.2
# c = constant (optional), with default value 2*pi
#
##########################################################################
d <- length(xx)
sum1 <- sum(xx^2)
sum2 <- sum(cos(c*xx))
term1 <- -a * exp(-b*sqrt(sum1/d))
term2 <- -exp(sum2/d)
y <- term1 + term2 + a + exp(1)
return(y)
}
#Reference Paper: Xin-She Yang, Nature-Inspired Metaheuristic Algorithms (second edition), pg 81-89, Luniver Press-2010
#You can either give your own input while running Firefly_algo in the bottom of this page or can leave default
#Inputs: no_firefly (total number of fireflies), N_iteration (number of timesteps),alpha (Randomness),betmin (Minimum value of beta (the attractiveness parameter)),gamma(Absorption coefficient), rng (minumum and maximum value), Fun (desired function to optimize)
firefly_algo <- function (no_firefly,N_iteration,alpha, betamin, gamma,rng,FunA = Fun){
#Check input parameters (otherwise set as default values)
# the input parameter is assumed in sequence
nargin <- nargs()
if (nargin < 1){
rng <-c(-1,1)
para <- c(20,50,0.25,0.20,1)
}
#Assume only one input parameter i.e. no_firefly is only passed to the function then rest of the parameter is initialized by the function
else if (nargin<2){
para <-c(no_firefly,50,0.25,0.20,1)
rng <-c(-1,1)
}
else if (nargin < 3){
para <-c(no_firefly,N_iteration,0.25,0.20,1)
rng <-c(-1,1)
}
else if (nargin < 4){
para <-c(no_firefly,N_iteration,alpha,0.20,1)
rng <-c(-1,1)
}
else if (nargin < 5){
para <-c(no_firefly,N_iteration,alpha, betamin,1)
rng <-c(-1,1)
}
else if (nargin < 6){
para <-c(no_firefly,N_iteration,alpha, betamin, gamma )
rng <-c(-1,1)
}
else {
rng<-c(rng[1],rng[2])
para <-c(no_firefly,N_iteration,alpha, betamin,gamma)
}
#Assign values to each variables
no_firefly <- para[1]
MaxGeneration <- para[2]
alpha <- para[3]
betamin <- para[4]
gamma <- para[5]
#Generate the initial locations of n fireflies
init_ffa <- function (no_firefly,rng){
ak<-rng[2] - rng[1]
x1n <- t(matrix(runif(no_firefly)*ak + rng[1]))
x2n <- t(matrix(runif(no_firefly)*ak + rng[1]))
Lightn <-matrix (0,nrow(x1n),ncol(x1n))
return(list(x1n,x2n,Lightn))		#initial value before function evaluations
}
#Make sure the fireflies are within the range
findrange_r <- function (x1n,x2n, rng){
for (i in 1: length(x1n)){
if (x1n[i] <= rng[1]){
x1n[i] <- rng[1]
}
if (x1n[i] >= rng[2]){
x1n[i] <- rng[2]
}
if (x2n[i]<= rng[1]){
x2n[i] <-rng[1]
}
if (x2n[i] >= rng[2]){
x2n[i]=rng[2]
}
}
return (list(x1n,x2n))
}
#Move all fireflies to the better locations
ffa_move <-function (x1n,x2n,Lightn,x1o,x2o,Lighto,alpha,gamma,rng){
ni = length(x1n)
nj= length(x1o)
for (i in 1:ni){
for (j in 1:nj){
r = sqrt((x1n[i]-x1o[j])^2 + (x2n[i]-x2o[j])^2) # This is the euclidian distance but you can change it according to ur needs
if (Lightn[i]<Lighto[j]){
beta0 =1
#if you are not using betamin then beta <- beta0 * exp((-gamma) * r^2)
beta<-(beta0-betamin)* exp(-gamma * r^2)+ betamin
x1n[i] <- x1n[i]*(1-beta) + (x1o[j]*beta) +(alpha * (runif(1)-0.5)) # * exp(-0.2*log(downscale)))
x2n[i] <- x2n[i]*(1-beta)+ (x2o[j] * beta) + (alpha * (runif(1) -0.5))	# * exp(-0.2*log(downscale)))
}
}
}
fdr <- findrange_r(x1n,x2n,rng);
x1n <-fdr[[1]]
x2n <-fdr[[2]]
return (list(x1n,x2n))
}
## This function is optional, as it is not in the original FA. The idea to reduce randomness is to increase the convergence, however, if you reduce randomness too quickly, then premature convergence can occur. So use with care.
alpha_new<-function(alpha,NGen){
#alpha_n=alpha_0(1-delta)^NGen=0.005
#alpha_0=0.9
delta<-1-(0.005/0.9)^(1/NGen)
alpha<-(1-delta)*alpha
}
#Initial values of an array
zn <-rep((10^100),no_firefly)
As<-init_ffa(no_firefly,rng)
x1n <-As[[1]]
x2n <-As[[2]]
Lightn <-As[[3]]
for (i in 1:MaxGeneration){
alpha=alpha_new(alpha,MaxGeneration) # This is optional
prob <- c(0.8,0.2)
zn <-FunA(x1n,x2n)
# Ranking the fireflies by their light intensity
tmp<-sort(zn,index.return=TRUE)
Lightn<-tmp$x
idx<-tmp$ix  #idx is index
##Reordering of fireflies by their light intensity
x1n<-x1n[idx]
x2n=x2n[idx]
# initial value of xo, yo and Lighto is changed here
x1o<-x1n
x2o<-x2n
Lighto<-Lightn
# Move all fireflies to the better locations
tmp_move<- ffa_move(x1n,x2n,Lightn,x1o,x2o,Lighto,alpha,gamma,rng)
x1n <-tmp_move[[1]]
x2n <- tmp_move[[2]]
}
# Output
best <-cbind(x1n,x2n,Lightn)
return (best)
}
set.seed(1)
#Function to optimize (User might want to change this )
Fun <- ackley
firefly_algo()
#Reference Paper: Xin-She Yang, Nature-Inspired Metaheuristic Algorithms (second edition), pg 81-89, Luniver Press-2010
#You can either give your own input while running Firefly_algo in the bottom of this page or can leave default
#Inputs: no_firefly (total number of fireflies), N_iteration (number of timesteps),alpha (Randomness),betmin (Minimum value of beta (the attractiveness parameter)),gamma(Absorption coefficient), rng (minumum and maximum value), Fun (desired function to optimize)
firefly_algo <- function (no_firefly,N_iteration,alpha, betamin, gamma,rng,FunA = Fun){
#Check input parameters (otherwise set as default values)
# the input parameter is assumed in sequence
nargin <- nargs()
if (nargin < 1){
rng <-c(-1,1)
para <- c(20,50,0.25,0.20,1)
}
#Assume only one input parameter i.e. no_firefly is only passed to the function then rest of the parameter is initialized by the function
else if (nargin<2){
para <-c(no_firefly,50,0.25,0.20,1)
rng <-c(-1,1)
}
else if (nargin < 3){
para <-c(no_firefly,N_iteration,0.25,0.20,1)
rng <-c(-1,1)
}
else if (nargin < 4){
para <-c(no_firefly,N_iteration,alpha,0.20,1)
rng <-c(-1,1)
}
else if (nargin < 5){
para <-c(no_firefly,N_iteration,alpha, betamin,1)
rng <-c(-1,1)
}
else if (nargin < 6){
para <-c(no_firefly,N_iteration,alpha, betamin, gamma )
rng <-c(-1,1)
}
else {
rng<-c(rng[1],rng[2])
para <-c(no_firefly,N_iteration,alpha, betamin,gamma)
}
#Assign values to each variables
no_firefly <- para[1]
MaxGeneration <- para[2]
alpha <- para[3]
betamin <- para[4]
gamma <- para[5]
#Generate the initial locations of n fireflies
init_ffa <- function (no_firefly,rng){
ak<-rng[2] - rng[1]
x1n <- t(matrix(runif(no_firefly)*ak + rng[1]))
x2n <- t(matrix(runif(no_firefly)*ak + rng[1]))
Lightn <-matrix (0,nrow(x1n),ncol(x1n))
return(list(x1n,x2n,Lightn))		#initial value before function evaluations
}
#Make sure the fireflies are within the range
findrange_r <- function (x1n,x2n, rng){
for (i in 1: length(x1n)){
if (x1n[i] <= rng[1]){
x1n[i] <- rng[1]
}
if (x1n[i] >= rng[2]){
x1n[i] <- rng[2]
}
if (x2n[i]<= rng[1]){
x2n[i] <-rng[1]
}
if (x2n[i] >= rng[2]){
x2n[i]=rng[2]
}
}
return (list(x1n,x2n))
}
#Move all fireflies to the better locations
ffa_move <-function (x1n,x2n,Lightn,x1o,x2o,Lighto,alpha,gamma,rng){
ni = length(x1n)
nj= length(x1o)
for (i in 1:ni){
for (j in 1:nj){
r = sqrt((x1n[i]-x1o[j])^2 + (x2n[i]-x2o[j])^2) # This is the euclidian distance but you can change it according to ur needs
if (Lightn[i]<Lighto[j]){
beta0 =1
#if you are not using betamin then beta <- beta0 * exp((-gamma) * r^2)
beta<-(beta0-betamin)* exp(-gamma * r^2)+ betamin
x1n[i] <- x1n[i]*(1-beta) + (x1o[j]*beta) +(alpha * (runif(1)-0.5)) # * exp(-0.2*log(downscale)))
x2n[i] <- x2n[i]*(1-beta)+ (x2o[j] * beta) + (alpha * (runif(1) -0.5))	# * exp(-0.2*log(downscale)))
}
}
}
fdr <- findrange_r(x1n,x2n,rng);
x1n <-fdr[[1]]
x2n <-fdr[[2]]
return (list(x1n,x2n))
}
## This function is optional, as it is not in the original FA. The idea to reduce randomness is to increase the convergence, however, if you reduce randomness too quickly, then premature convergence can occur. So use with care.
alpha_new<-function(alpha,NGen){
#alpha_n=alpha_0(1-delta)^NGen=0.005
#alpha_0=0.9
delta<-1-(0.005/0.9)^(1/NGen)
alpha<-(1-delta)*alpha
}
#Initial values of an array
zn <-rep((10^100),no_firefly)
As<-init_ffa(no_firefly,rng)
x1n <-As[[1]]
x2n <-As[[2]]
Lightn <-As[[3]]
for (i in 1:MaxGeneration){
alpha=alpha_new(alpha,MaxGeneration) # This is optional
prob <- c(0.8,0.2)
zn <-FunA(x1n,x2n)
# Ranking the fireflies by their light intensity
tmp<-sort(zn,index.return=TRUE)
Lightn<-tmp$x
idx<-tmp$ix  #idx is index
##Reordering of fireflies by their light intensity
x1n<-x1n[idx]
x2n=x2n[idx]
# initial value of xo, yo and Lighto is changed here
x1o<-x1n
x2o<-x2n
Lighto<-Lightn
# Move all fireflies to the better locations
tmp_move<- ffa_move(x1n,x2n,Lightn,x1o,x2o,Lighto,alpha,gamma,rng)
x1n <-tmp_move[[1]]
x2n <- tmp_move[[2]]
}
# Output
best <-cbind(x1n,x2n,Lightn)
return (best)
}
set.seed(1)
#Function to optimize (User might want to change this )
Fun <- function(x,y){
str1=exp(-(x-4)^2-(y-4)^2)+exp(-(x+4)^2-(y-4)^2)+2*exp(-x^2-(y+4)^2)+2*exp(-x^2-y^2)
return (str1)
}
firefly_algo()
psoptim <- function(FUN, n=100, max.loop=100, w=.9, c1=.2, c2=.2, xmin, xmax, vmax=c(4,4), seed=10, anim=TRUE)
{
#FUN - nazwa optymalizowanej funkcji, funkcja musi byc jednoargumentowa
#co oznacza ze argumentem jest wektor
# n - liczba czastek w roju
# max.loop - maksymalna liczba iteracji
# w - wspolczynnik bezwladnosci
# c1 - wspolczynnik wlasnego "zaufania"
# c2 - wspolczynnik "zaufania" do roju
# xmin - wektor okreslajacy dolne ograniczenia wartosci zmiennych
# xmax - wektor okreslajacy gorne ograniczenia wartosci zmiennych
# vmax - wektor ograniczen predkosci w kazdym kierunku
# seed - liczba naturalna okreslajaca tzw. ziarno dla generatora liczb
#pseudolosowych argument stosowany w celu uzyskania powtarzalnosci otrzymywanych wynikow
# anim - wartosc logiczna, jesli prawda TRUE(wartosc domyslna), to animacja przebiegu
# optymalizajci jest wlaczona
g1 <- function(x,y)
{
FUN(cbind(x,y))
}
d <- length(xmin)
set.seed(seed)
x <- matrix(nrow=n, ncol=d)
for(i in 1:d)
x[,i] <- runif(n, xmin[1],xmax[1])
wart.f <- FUN(x)
x.best.czastki <- x
x.best.roju <- matrix(x[which.max(wart.f),], ncol=d)
if((d == 2) && anim)
{
x_image <- matrix(c(seq(from=xmin[1],to=xmax[1],length.out=100),seq(from=xmin[2],to=xmax[2],length.out=100)), ncol=2)
z <- outer(x_image[,1], x_image[,2], g1)
image(x_image[,1], x_image[,2], z, xlab="x1", ylab="x2", main="Initial swarm")
contour(x_image[,1], x_image[,2], z, nlevels=10, add=TRUE, col="grey50")
points(x[,1], x[,2], pch=19, col="darkslateblue")
}
if (interactive() && anim && (d==2)) {
invisible(readline(prompt = "Press <Enter>/<Return> to continue..."))
}
v <- matrix(runif(n*d, min=-vmax, max=vmax), ncol=d, nrow=n)
g.mean <- c()
g.best <- c()
loop <- 1
while(loop <= max.loop)
{
wart.f <- FUN(x)
g.mean <- rbind(g.mean, mean(wart.f))
idx <- which(wart.f > FUN(x.best.czastki))
x.best.czastki[idx,] <- x[idx,]
x.best.roju.nowe <- matrix(x[which.max(FUN(x.best.czastki)),],ncol=d)
if(FUN(x.best.roju.nowe) > FUN(x.best.roju))
x.best.roju <- x.best.roju.nowe
g.best <- rbind(g.best, FUN(x.best.roju))
for(i in 1:n)
{
for(j in 1:d)
{
r1 <- runif(1)
r2 <- runif(1)
v[i,j] <- w*v[i,j] + c1*r1*(x.best.czastki[i,j] - x[i,j]) +  c2*r2*(x.best.roju[j]-x[i,j])
if(v[i,j] > vmax[j] || v[i,j] < -vmax[j])
v[i,j] <- vmax[j]
x_prev <- x[i,j]
x[i,j] <- x[i,j] + v[i,j]
if(x[i,j] > xmax[j])
x[i,j] <- x_prev
if(x[i,j] < xmin[j])
x[i,j] <- x_prev
}
}
if((d==2) && anim)
{
contour(x_image[,1], x_image[,2], z, nlevels=20, xlab="x1", ylab="x2", col="darkgray", main=paste(loop, "/", max.loop))
points(x, xlim=c(xmin[1], xmax[1]), ylim=c(xmin[2], xmax[2]), pch=21, bg="cadetblue")
# points(x, xlim=c(xmin[1], xmax[1]), ylim=c(xmin[2], xmax[2]), pch=21, bg=densCols(x))
}
loop <- loop + 1
}
if(anim)
{
if (interactive() & (d==2)) {
invisible(readline(prompt = "Press <Enter>/<Return> to continue..."))
}
}
plot(g.best, type="o", col="darkgreen", pch=19, cex=.7, ylim=c(min(g.mean),max(g.best)), xlab="Iteration", ylab="Fitness value")
lines(g.mean, type="o", col="blue", cex=.7, pch=19)
legend("bottomright", legend = c("Best", "Mean"), col = c("darkgreen", "blue"), pch = 19, lty = 1, merge = TRUE)
colnames(x.best.roju) <- paste("x", seq(1:d), sep="")
res <- list(sol = x.best.roju, val=g.best[loop-1])
return(res)
}
psoptim <- function(FUN, n=100, max.loop=100, w=.9, c1=.2, c2=.2, xmin, xmax, vmax=c(4,4), seed=10, anim=TRUE)
{
#FUN - nazwa optymalizowanej funkcji, funkcja musi byc jednoargumentowa
#co oznacza ze argumentem jest wektor
# n - liczba czastek w roju
# max.loop - maksymalna liczba iteracji
# w - wspolczynnik bezwladnosci
# c1 - wspolczynnik wlasnego "zaufania"
# c2 - wspolczynnik "zaufania" do roju
# xmin - wektor okreslajacy dolne ograniczenia wartosci zmiennych
# xmax - wektor okreslajacy gorne ograniczenia wartosci zmiennych
# vmax - wektor ograniczen predkosci w kazdym kierunku
# seed - liczba naturalna okreslajaca tzw. ziarno dla generatora liczb
#pseudolosowych argument stosowany w celu uzyskania powtarzalnosci otrzymywanych wynikow
# anim - wartosc logiczna, jesli prawda TRUE(wartosc domyslna), to animacja przebiegu
# optymalizajci jest wlaczona
g1 <- function(x,y)
{
FUN(cbind(x,y))
}
d <- length(xmin)
set.seed(seed)
x <- matrix(nrow=n, ncol=d)
for(i in 1:d)
x[,i] <- runif(n, xmin[1],xmax[1])
wart.f <- FUN(x)
x.best.czastki <- x
x.best.roju <- matrix(x[which.max(wart.f),], ncol=d)
if((d == 2) && anim)
{
x_image <- matrix(c(seq(from=xmin[1],to=xmax[1],length.out=100),seq(from=xmin[2],to=xmax[2],length.out=100)), ncol=2)
z <- outer(x_image[,1], x_image[,2], g1)
image(x_image[,1], x_image[,2], z, xlab="x1", ylab="x2", main="Initial swarm")
contour(x_image[,1], x_image[,2], z, nlevels=10, add=TRUE, col="grey50")
points(x[,1], x[,2], pch=19, col="darkslateblue")
}
if (interactive() && anim && (d==2)) {
invisible(readline(prompt = "Press <Enter>/<Return> to continue..."))
}
v <- matrix(runif(n*d, min=-vmax, max=vmax), ncol=d, nrow=n)
g.mean <- c()
g.best <- c()
loop <- 1
while(loop <= max.loop)
{
wart.f <- FUN(x)
g.mean <- rbind(g.mean, mean(wart.f))
idx <- which(wart.f > FUN(x.best.czastki))
x.best.czastki[idx,] <- x[idx,]
x.best.roju.nowe <- matrix(x[which.max(FUN(x.best.czastki)),],ncol=d)
if(FUN(x.best.roju.nowe) > FUN(x.best.roju))
x.best.roju <- x.best.roju.nowe
g.best <- rbind(g.best, FUN(x.best.roju))
for(i in 1:n)
{
for(j in 1:d)
{
r1 <- runif(1)
r2 <- runif(1)
v[i,j] <- w*v[i,j] + c1*r1*(x.best.czastki[i,j] - x[i,j]) +  c2*r2*(x.best.roju[j]-x[i,j])
if(v[i,j] > vmax[j] || v[i,j] < -vmax[j])
v[i,j] <- vmax[j]
x_prev <- x[i,j]
x[i,j] <- x[i,j] + v[i,j]
if(x[i,j] > xmax[j])
x[i,j] <- x_prev
if(x[i,j] < xmin[j])
x[i,j] <- x_prev
}
}
if((d==2) && anim)
{
contour(x_image[,1], x_image[,2], z, nlevels=20, xlab="x1", ylab="x2", col="darkgray", main=paste(loop, "/", max.loop))
points(x, xlim=c(xmin[1], xmax[1]), ylim=c(xmin[2], xmax[2]), pch=21, bg="cadetblue")
# points(x, xlim=c(xmin[1], xmax[1]), ylim=c(xmin[2], xmax[2]), pch=21, bg=densCols(x))
}
loop <- loop + 1
}
if(anim)
{
if (interactive() & (d==2)) {
invisible(readline(prompt = "Press <Enter>/<Return> to continue..."))
}
}
plot(g.best, type="o", col="darkgreen", pch=19, cex=.7, ylim=c(min(g.mean),max(g.best)), xlab="Iteration", ylab="Fitness value")
lines(g.mean, type="o", col="blue", cex=.7, pch=19)
legend("bottomright", legend = c("Best", "Mean"), col = c("darkgreen", "blue"), pch = 19, lty = 1, merge = TRUE)
colnames(x.best.roju) <- paste("x", seq(1:d), sep="")
res <- list(sol = x.best.roju, val=g.best[loop-1])
return(res)
}
