x1n[i] <- rng[1]
}
if (x1n[i] >= rng[2]){
x1n[i] <- rng[2]
}
if (x2n[i]<= rng[1]){
x2n[i] <-rng[1]
}
if (x2n[i] >= rng[2]){
x2n[i]=rng[2]
}
}
return (list(x1n,x2n))
}
#Move all fireflies to the better locations
ffa_move <-function (x1n,x2n,Lightn,x1o,x2o,Lighto,alpha,gamma,rng){
ni = length(x1n)
nj= length(x1o)
for (i in 1:ni){
for (j in 1:nj){
r = sqrt((x1n[i]-x1o[j])^2 + (x2n[i]-x2o[j])^2) # This is the euclidian distance but you can change it according to ur needs
if (Lightn[i]<Lighto[j]){
beta0 =1
#if you are not using betamin then beta <- beta0 * exp((-gamma) * r^2)
beta<-(beta0-betamin)* exp(-gamma * r^2)+ betamin
x1n[i] <- x1n[i]*(1-beta) + (x1o[j]*beta) +(alpha * (runif(1)-0.5)) # * exp(-0.2*log(downscale)))
x2n[i] <- x2n[i]*(1-beta)+ (x2o[j] * beta) + (alpha * (runif(1) -0.5))	# * exp(-0.2*log(downscale)))
}
}
}
fdr <- findrange_r(x1n,x2n,rng);
x1n <-fdr[[1]]
x2n <-fdr[[2]]
return (list(x1n,x2n))
}
## This function is optional, as it is not in the original FA. The idea to reduce randomness is to increase the convergence, however, if you reduce randomness too quickly, then premature convergence can occur. So use with care.
alpha_new<-function(alpha,NGen){
#alpha_n=alpha_0(1-delta)^NGen=0.005
#alpha_0=0.9
delta<-1-(0.005/0.9)^(1/NGen)
alpha<-(1-delta)*alpha
}
#Initial values of an array
zn <-rep((10^100),no_firefly)
As<-init_ffa(no_firefly,rng)
x1n <-As[[1]]
x2n <-As[[2]]
Lightn <-As[[3]]
for (i in 1:MaxGeneration){
alpha=alpha_new(alpha,MaxGeneration) # This is optional
prob <- c(0.8,0.2)
zn <-FunA(x1n,x2n)
# Ranking the fireflies by their light intensity
tmp<-sort(zn,index.return=TRUE)
Lightn<-tmp$x
idx<-tmp$ix  #idx is index
##Reordering of fireflies by their light intensity
x1n<-x1n[idx]
x2n=x2n[idx]
# initial value of xo, yo and Lighto is changed here
x1o<-x1n
x2o<-x2n
Lighto<-Lightn
# Move all fireflies to the better locations
czas.rysunkow = proc.time()
plot(x1o,x2o,main="Pozycje świetlików",type = "p",col="darkred",xlab="x1", ylab="x2",xlim=range(rng[1]:rng[2]),ylim=range(rng[1]:rng[2]))
czas.rysunkow2 = proc.time()-czas.rysunkow
czas.stracony=czas.stracony+czas.rysunkow2
#points(x, xlim=c(rng[1], rng[2]), ylim=c(rng[1], rng[2]), pch=21, bg="cadetblue")
tmp_move<- ffa_move(x1n,x2n,Lightn,x1o,x2o,Lighto,alpha,gamma,rng)
x1n <-tmp_move[[1]]
x2n <- tmp_move[[2]]
}
# Output
best <-cbind(x1n,x2n,Lightn)
print(proc.time() - ptm-czas.stracony)
plot(Lightn, type= "o",col="darkblue",xlab="Iteracje", ylab="Znalenione minimum")
return (best,proc.time() - ptm-czas.stracony)
}
set.seed(5)
#Algorytm domyślnie liczy maksimum funkcji wiec trzeba funkcje pomnozyc *-1
funkcja = ackley.gso #przykladowo
zakres <- c(-5.12,5.12) # zakres
para <- c(100,20,0.25,0.20,1) #no_firefly,N_iteration,alpha, betamin, gamma
firefly_algo(no_firefly,N_iteration,alpha, betamin, gamma,rng=zakres,FunA=funkcja)
source('C:/Users/Konasz/Desktop/projekt/algorytmy optymalizacyjne/Firefly(alg.swietlikow).R')
#Algorytm domyślnie liczy maksimum funkcji wiec trzeba funkcje pomnozyc *-1
funkcja = ackley.gso #przykladowo
zakres <- c(-5.12,5.12) # zakres
para <- c(100,20,0.25,0.20,1) #no_firefly,N_iteration,alpha, betamin, gamma
firefly_algo(no_firefly,N_iteration,alpha, betamin, gamma,rng=zakres,FunA=funkcja)
source('C:/Users/Konasz/Desktop/projekt/algorytmy optymalizacyjne/Firefly(alg.swietlikow).R')
#Algorytm domyślnie liczy maksimum funkcji wiec trzeba funkcje pomnozyc *-1
funkcja = ackley.gso #przykladowo
zakres <- c(-5.12,5.12) # zakres
para <- c(100,20,0.25,0.20,1) #no_firefly,N_iteration,alpha, betamin, gamma
firefly_algo(no_firefly,N_iteration,alpha, betamin, gamma,rng=zakres,FunA=funkcja)
source('C:/Users/Konasz/Desktop/projekt/algorytmy optymalizacyjne/Firefly(alg.swietlikow).R')
#Algorytm domyślnie liczy maksimum funkcji wiec trzeba funkcje pomnozyc *-1
funkcja = ackley.gso #przykladowo
zakres <- c(-5.12,5.12) # zakres
para <- c(100,20,0.25,0.20,1) #no_firefly,N_iteration,alpha, betamin, gamma
firefly_algo(no_firefly,N_iteration,alpha, betamin, gamma,rng=zakres,FunA=funkcja)
#Algorytm domyślnie liczy maksimum funkcji wiec trzeba funkcje pomnozyc *-1
funkcja = ackley.gso #przykladowo
zakres <- c(-5.12,5.12) # zakres
para <- c(100,20,0.25,0.20,1) #no_firefly,N_iteration,alpha, betamin, gamma
firefly_algo(no_firefly,N_iteration,alpha, betamin, gamma,rng=zakres,FunA=funkcja)
print(wynikczasu)
source('C:/Users/Konasz/Desktop/projekt/algorytmy optymalizacyjne/Firefly(alg.swietlikow).R')
#Algorytm domyślnie liczy maksimum funkcji wiec trzeba funkcje pomnozyc *-1
funkcja = ackley.gso #przykladowo
zakres <- c(-5.12,5.12) # zakres
para <- c(100,20,0.25,0.20,1) #no_firefly,N_iteration,alpha, betamin, gamma
firefly_algo(no_firefly,N_iteration,alpha, betamin, gamma,rng=zakres,FunA=funkcja)
print(wynikczasu)
source('C:/Users/Konasz/Desktop/projekt/algorytmy optymalizacyjne/Firefly(alg.swietlikow).R')
#Algorytm domyślnie liczy maksimum funkcji wiec trzeba funkcje pomnozyc *-1
funkcja = ackley.gso #przykladowo
zakres <- c(-5.12,5.12) # zakres
para <- c(100,20,0.25,0.20,1) #no_firefly,N_iteration,alpha, betamin, gamma
firefly_algo(no_firefly,N_iteration,alpha, betamin, gamma,rng=zakres,FunA=funkcja)
source('C:/Users/Konasz/Desktop/projekt/algorytmy optymalizacyjne/Firefly(alg.swietlikow).R')
#Algorytm domyślnie liczy maksimum funkcji wiec trzeba funkcje pomnozyc *-1
funkcja = ackley.gso #przykladowo
zakres <- c(-5.12,5.12) # zakres
para <- c(100,20,0.25,0.20,1) #no_firefly,N_iteration,alpha, betamin, gamma
firefly_algo(no_firefly,N_iteration,alpha, betamin, gamma,rng=zakres,FunA=funkcja)
source('C:/Users/Konasz/Desktop/projekt/algorytmy optymalizacyjne/Firefly(alg.swietlikow).R')
#Algorytm domyślnie liczy maksimum funkcji wiec trzeba funkcje pomnozyc *-1
funkcja = ackley.gso #przykladowo
zakres <- c(-5.12,5.12) # zakres
para <- c(100,20,0.25,0.20,1) #no_firefly,N_iteration,alpha, betamin, gamma
firefly_algo(no_firefly,N_iteration,alpha, betamin, gamma,rng=zakres,FunA=funkcja)
wynikczasu
#Algorytm domyślnie liczy maksimum funkcji wiec trzeba funkcje pomnozyc *-1
funkcja = ackley.gso #przykladowo
zakres <- c(-5.12,5.12) # zakres
para <- c(100,20,0.25,0.20,1) #no_firefly,N_iteration,alpha, betamin, gamma
firefly_algo(no_firefly,N_iteration,alpha, betamin, gamma,rng=zakres,FunA=funkcja,wynikczasu)
wynikczasu
#Algorytm domyślnie liczy maksimum funkcji wiec trzeba funkcje pomnozyc *-1
funkcja = ackley.gso #przykladowo
zakres <- c(-5.12,5.12) # zakres
para <- c(100,20,0.25,0.20,1) #no_firefly,N_iteration,alpha, betamin, gamma
firefly_algo(no_firefly,N_iteration,alpha, betamin, gamma,rng=zakres,FunA=funkcja)
wynikczasu
source('C:/Users/Konasz/Desktop/projekt/testy/optymalizacja GSO.R')
source('C:/Users/Konasz/Desktop/projekt/algorytmy optymalizacyjne/PSO(roj czastek).R')
n <- 50
m.l <- 50
w <- 0.95
c1 <- 0.2
c2 <- 0.2
xmin <- c(-32, -32)
xmax <- c(32, 32)
vmax <- c(4, 4)
psoptim(FUN=ackley.pso, n=n, max.loop=m.l, w=w, c1=c1, c2=c2,
xmin=xmin, xmax=xmax, vmax=vmax, seed=5)
wynikczasu
n <- 50
m.l <- 50
w <- 0.95
c1 <- 0.2
c2 <- 0.2
xmin <- c(-32, -32)
xmax <- c(32, 32)
vmax <- c(4, 4)
psoptim(FUN=ackley.pso, n=n, max.loop=m.l, w=w, c1=c1, c2=c2,
xmin=xmin, xmax=xmax, vmax=vmax, seed=5)
source('C:/Users/Konasz/Desktop/projekt/algorytmy optymalizacyjne/PSO(roj czastek).R')
n <- 50
m.l <- 50
w <- 0.95
c1 <- 0.2
c2 <- 0.2
xmin <- c(-32, -32)
xmax <- c(32, 32)
vmax <- c(4, 4)
psoptim(FUN=ackley.pso, n=n, max.loop=m.l, w=w, c1=c1, c2=c2,
xmin=xmin, xmax=xmax, vmax=vmax, seed=5)
source('C:/Users/Konasz/Desktop/projekt/testy/opt pso orginalna.R')
source('C:/Users/Konasz/Desktop/projekt/testy/opt pso orginalna.R')
psoptim <- function(FUN, n=100, max.loop=100, w=.9, c1=.2, c2=.2, xmin, xmax, vmax=c(4,4), seed=10, anim=TRUE)
{
ptm <- proc.time()
czas.stracony =0
#czas trzeba mierzyc z anim=FALSE
#FUN - nazwa optymalizowanej funkcji, funkcja musi byc jednoargumentowa
#co oznacza ze argumentem jest wektor
# n - liczba czastek w roju
# max.loop - maksymalna liczba iteracji
# w - wspolczynnik bezwladnosci
# c1 - wspolczynnik wlasnego "zaufania"
# c2 - wspolczynnik "zaufania" do roju
# xmin - wektor okreslajacy dolne ograniczenia wartosci zmiennych
# xmax - wektor okreslajacy gorne ograniczenia wartosci zmiennych
# vmax - wektor ograniczen predkosci w kazdym kierunku
# seed - liczba naturalna okreslajaca tzw. ziarno dla generatora liczb
#pseudolosowych argument stosowany w celu uzyskania powtarzalnosci otrzymywanych wynikow
# anim - wartosc logiczna, jesli prawda TRUE(wartosc domyslna), to animacja przebiegu
# optymalizajci jest wlaczona
g1 <- function(x,y)
{
FUN(cbind(x,y))
}
d <- length(xmin)
set.seed(seed)
x <- matrix(nrow=n, ncol=d)
for(i in 1:d)
x[,i] <- runif(n, xmin[1],xmax[1])
wart.f <- FUN(x)
x.best.czastki <- x
x.best.roju <- matrix(x[which.max(wart.f),], ncol=d)
if((d == 2) && anim)
{
x_image <- matrix(c(seq(from=xmin[1],to=xmax[1],length.out=100),seq(from=xmin[2],to=xmax[2],length.out=100)), ncol=2)
z <- outer(x_image[,1], x_image[,2], g1)
image(x_image[,1], x_image[,2], z, xlab="x1", ylab="x2", main="Initial swarm")
contour(x_image[,1], x_image[,2], z, nlevels=10, add=TRUE, col="grey50")
points(x[,1], x[,2], pch=19, col="darkslateblue")
}
if (interactive() && anim && (d==2)) {
invisible(readline(prompt = "Press <Enter>/<Return> to continue..."))
}
v <- matrix(runif(n*d, min=-vmax, max=vmax), ncol=d, nrow=n)
g.mean <- c()
g.best <- c()
loop <- 1
while(loop <= max.loop)
{
wart.f <- FUN(x)
g.mean <- rbind(g.mean, mean(wart.f))
idx <- which(wart.f > FUN(x.best.czastki))
x.best.czastki[idx,] <- x[idx,]
x.best.roju.nowe <- matrix(x[which.max(FUN(x.best.czastki)),],ncol=d)
if(FUN(x.best.roju.nowe) > FUN(x.best.roju))
x.best.roju <- x.best.roju.nowe
g.best <- rbind(g.best, FUN(x.best.roju))
for(i in 1:n)
{
for(j in 1:d)
{
r1 <- runif(1)
r2 <- runif(1)
v[i,j] <- w*v[i,j] + c1*r1*(x.best.czastki[i,j] - x[i,j]) +  c2*r2*(x.best.roju[j]-x[i,j])
if(v[i,j] > vmax[j] || v[i,j] < -vmax[j])
v[i,j] <- vmax[j]
x_prev <- x[i,j]
x[i,j] <- x[i,j] + v[i,j]
if(x[i,j] > xmax[j])
x[i,j] <- x_prev
if(x[i,j] < xmin[j])
x[i,j] <- x_prev
}
}
if((d==2) && anim)
{
czas.rysunkow = proc.time()
contour(x_image[,1], x_image[,2], z, nlevels=20, xlab="x1", ylab="x2", col="darkgray", main=paste(loop, "/", max.loop))
points(x, xlim=c(xmin[1], xmax[1]), ylim=c(xmin[2], xmax[2]), pch=21, bg="cadetblue")
czas.rysunkow2 = proc.time()-czas.rysunkow
czas.stracony=czas.stracony+czas.rysunkow2
# points(x, xlim=c(xmin[1], xmax[1]), ylim=c(xmin[2], xmax[2]), pch=21, bg=densCols(x))
}
loop <- loop + 1
}
if(anim)
{
if (interactive() & (d==2)) {
invisible(readline(prompt = "Press <Enter>/<Return> to continue..."))
}
}
wynikczasu<<-proc.time() - ptm-czas.stracony
print(wynikczasu)
plot(g.best, type="o", col="darkgreen", pch=19, cex=.7, ylim=c(min(g.mean),max(g.best)), xlab="Iteration", ylab="Fitness value")
lines(g.mean, type="o", col="blue", cex=.7, pch=19)
legend("bottomright", legend = c("Best", "Mean"), col = c("darkgreen", "blue"), pch = 19, lty = 1, merge = TRUE)
colnames(x.best.roju) <- paste("x", seq(1:d), sep="")
res <- list(sol = x.best.roju, val=g.best[loop-1])
return(res)
}
source('~/.active-rstudio-document')
n <- 50
m.l <- 50
w <- 0.95
c1 <- 0.2
c2 <- 0.2
xmin <- c(-32, -32)
xmax <- c(32, 32)
vmax <- c(4, 4)
psoptim(FUN=ackley.pso, n=n, max.loop=m.l, w=w, c1=c1, c2=c2,
xmin=xmin, xmax=xmax, vmax=vmax, seed=5)
psoptim <- function(FUN, n=100, max.loop=100, w=.9, c1=.2, c2=.2, xmin, xmax, vmax=c(4,4), seed=10, anim=TRUE)
{
ptm <- proc.time()
czas.stracony =0
#czas trzeba mierzyc z anim=FALSE
#FUN - nazwa optymalizowanej funkcji, funkcja musi byc jednoargumentowa
#co oznacza ze argumentem jest wektor
# n - liczba czastek w roju
# max.loop - maksymalna liczba iteracji
# w - wspolczynnik bezwladnosci
# c1 - wspolczynnik wlasnego "zaufania"
# c2 - wspolczynnik "zaufania" do roju
# xmin - wektor okreslajacy dolne ograniczenia wartosci zmiennych
# xmax - wektor okreslajacy gorne ograniczenia wartosci zmiennych
# vmax - wektor ograniczen predkosci w kazdym kierunku
# seed - liczba naturalna okreslajaca tzw. ziarno dla generatora liczb
#pseudolosowych argument stosowany w celu uzyskania powtarzalnosci otrzymywanych wynikow
# anim - wartosc logiczna, jesli prawda TRUE(wartosc domyslna), to animacja przebiegu
# optymalizajci jest wlaczona
g1 <- function(x,y)
{
FUN(cbind(x,y))
}
d <- length(xmin)
set.seed(seed)
x <- matrix(nrow=n, ncol=d)
for(i in 1:d)
x[,i] <- runif(n, xmin[1],xmax[1])
wart.f <- FUN(x)
x.best.czastki <- x
x.best.roju <- matrix(x[which.max(wart.f),], ncol=d)
if((d == 2) && anim)
{
x_image <- matrix(c(seq(from=xmin[1],to=xmax[1],length.out=100),seq(from=xmin[2],to=xmax[2],length.out=100)), ncol=2)
z <- outer(x_image[,1], x_image[,2], g1)
image(x_image[,1], x_image[,2], z, xlab="x1", ylab="x2", main="Initial swarm")
contour(x_image[,1], x_image[,2], z, nlevels=10, add=TRUE, col="grey50")
points(x[,1], x[,2], pch=19, col="darkslateblue")
}
if (interactive() && anim && (d==2)) {
invisible(readline(prompt = "Press <Enter>/<Return> to continue..."))
}
v <- matrix(runif(n*d, min=-vmax, max=vmax), ncol=d, nrow=n)
g.mean <- c()
g.best <- c()
loop <- 1
while(loop <= max.loop)
{
wart.f <- FUN(x)
g.mean <- rbind(g.mean, mean(wart.f))
idx <- which(wart.f > FUN(x.best.czastki))
x.best.czastki[idx,] <- x[idx,]
x.best.roju.nowe <- matrix(x[which.max(FUN(x.best.czastki)),],ncol=d)
if(FUN(x.best.roju.nowe) > FUN(x.best.roju))
x.best.roju <- x.best.roju.nowe
g.best <- rbind(g.best, FUN(x.best.roju))
for(i in 1:n)
{
for(j in 1:d)
{
r1 <- runif(1)
r2 <- runif(1)
v[i,j] <- w*v[i,j] + c1*r1*(x.best.czastki[i,j] - x[i,j]) +  c2*r2*(x.best.roju[j]-x[i,j])
if(v[i,j] > vmax[j] || v[i,j] < -vmax[j])
v[i,j] <- vmax[j]
x_prev <- x[i,j]
x[i,j] <- x[i,j] + v[i,j]
if(x[i,j] > xmax[j])
x[i,j] <- x_prev
if(x[i,j] < xmin[j])
x[i,j] <- x_prev
}
}
if((d==2) && anim)
{
czas.rysunkow = proc.time()
contour(x_image[,1], x_image[,2], z, nlevels=20, xlab="x1", ylab="x2", col="darkgray", main=paste(loop, "/", max.loop))
points(x, xlim=c(xmin[1], xmax[1]), ylim=c(xmin[2], xmax[2]), pch=21, bg="cadetblue")
czas.rysunkow2 = proc.time()-czas.rysunkow
czas.stracony=czas.stracony+czas.rysunkow2
# points(x, xlim=c(xmin[1], xmax[1]), ylim=c(xmin[2], xmax[2]), pch=21, bg=densCols(x))
}
loop <- loop + 1
}
if(anim)
{
if (interactive() & (d==2)) {
invisible(readline(prompt = "Press <Enter>/<Return> to continue..."))
}
}
wynikczasu<<-proc.time() - ptm-czas.stracony
plot(g.best, type="o", col="darkgreen", pch=19, cex=.7, ylim=c(min(g.mean),max(g.best)), xlab="Iteration", ylab="Fitness value")
lines(g.mean, type="o", col="blue", cex=.7, pch=19)
legend("bottomright", legend = c("Best", "Mean"), col = c("darkgreen", "blue"), pch = 19, lty = 1, merge = TRUE)
colnames(x.best.roju) <- paste("x", seq(1:d), sep="")
res <- list(sol = x.best.roju, val=g.best[loop-1])
return(res)
}
n <- 50
m.l <- 50
w <- 0.95
c1 <- 0.2
c2 <- 0.2
xmin <- c(-32, -32)
xmax <- c(32, 32)
vmax <- c(4, 4)
psoptim(FUN=ackley.pso, n=n, max.loop=m.l, w=w, c1=c1, c2=c2,
xmin=xmin, xmax=xmax, vmax=vmax, seed=5)
source('C:/Users/Konasz/Desktop/projekt/algorytmy optymalizacyjne/PSO(roj czastek).R')
source('~/.active-rstudio-document')
print(wynikczasu)
source('C:/Users/Konasz/Desktop/projekt/algorytmy optymalizacyjne/PSO(roj czastek).R')
n <- 50
m.l <- 50
w <- 0.95
c1 <- 0.2
c2 <- 0.2
xmin <- c(-32, -32)
xmax <- c(32, 32)
vmax <- c(4, 4)
psoptim(FUN=ackley.pso, n=n, max.loop=m.l, w=w, c1=c1, c2=c2,
xmin=xmin, xmax=xmax, vmax=vmax, seed=5)
n <- 50
m.l <- 50
w <- 0.95
c1 <- 0.2
c2 <- 0.2
xmin <- c(-32, -32)
xmax <- c(32, 32)
vmax <- c(4, 4)
psoptim(FUN=ackley.pso, n=n, max.loop=m.l, w=w, c1=c1, c2=c2,
xmin=xmin, xmax=xmax, vmax=vmax, seed=5)
n <- 50
m.l <- 50
w <- 0.95
c1 <- 0.2
c2 <- 0.2
xmin <- c(-32, -32)
xmax <- c(32, 32)
vmax <- c(4, 4)
psoptim(FUN=ackley.pso, n=n, max.loop=m.l, w=w, c1=c1, c2=c2,
xmin=xmin, xmax=xmax, vmax=vmax, seed=5)
source('C:/Users/Konasz/Desktop/projekt/algorytmy optymalizacyjne/PSO(roj czastek).R')
n <- 50
m.l <- 50
w <- 0.95
c1 <- 0.2
c2 <- 0.2
xmin <- c(-32, -32)
xmax <- c(32, 32)
vmax <- c(4, 4)
psoptim(FUN=ackley.pso, n=n, max.loop=m.l, w=w, c1=c1, c2=c2,
xmin=xmin, xmax=xmax, vmax=vmax, seed=5)
source('C:/Users/Konasz/Desktop/projekt/algorytmy optymalizacyjne/PSO(roj czastek).R')
n <- 50
m.l <- 50
w <- 0.95
c1 <- 0.2
c2 <- 0.2
xmin <- c(-32, -32)
xmax <- c(32, 32)
vmax <- c(4, 4)
psoptim(FUN=ackley.pso, n=n, max.loop=m.l, w=w, c1=c1, c2=c2,
xmin=xmin, xmax=xmax, vmax=vmax, seed=5)
source('C:/Users/Konasz/Desktop/projekt/algorytmy optymalizacyjne/PSO(roj czastek).R')
n <- 50
m.l <- 50
w <- 0.95
c1 <- 0.2
c2 <- 0.2
xmin <- c(-32, -32)
xmax <- c(32, 32)
vmax <- c(4, 4)
psoptim(FUN=ackley.pso, n=n, max.loop=m.l, w=w, c1=c1, c2=c2,
xmin=xmin, xmax=xmax, vmax=vmax, seed=5)
source('C:/Users/Konasz/Desktop/projekt/algorytmy optymalizacyjne/PSO(roj czastek).R')
n <- 50
m.l <- 50
w <- 0.95
c1 <- 0.2
c2 <- 0.2
xmin <- c(-32, -32)
xmax <- c(32, 32)
vmax <- c(4, 4)
psoptim(FUN=ackley.pso, n=n, max.loop=m.l, w=w, c1=c1, c2=c2,
xmin=xmin, xmax=xmax, vmax=vmax, seed=5)
n <- 50
m.l <- 50
w <- 0.95
c1 <- 0.2
c2 <- 0.2
xmin <- c(-32, -32)
xmax <- c(32, 32)
vmax <- c(4, 4)
psoptim(FUN=ackley.pso, n=n, max.loop=m.l, w=w, c1=c1, c2=c2,
xmin=xmin, xmax=xmax, vmax=vmax, seed=5)
wynikczasu
source('C:/Users/Konasz/Desktop/projekt/testy/optymalizacja GSO.R')
#Algorytm domyślnie liczy maksimum funkcji wiec trzeba funkcje pomnozyc *-1
funkcja = ackley.gso #przykladowo
zakres <- c(-5.12,5.12) # zakres
para <- c(100,20,0.25,0.20,1) #no_firefly,N_iteration,alpha, betamin, gamma
firefly_algo(no_firefly,N_iteration,alpha, betamin, gamma,rng=zakres,FunA=funkcja)
wynikczasu
source('C:/Users/Konasz/Desktop/projekt/testy/optymalizacja GSO.R')
source('C:/Users/Konasz/Desktop/projekt/algorytmy optymalizacyjne/PSO(roj czastek).R')
source('C:/Users/Konasz/Desktop/projekt/testy/PSO funkcje.R')
source('C:/Users/Konasz/Desktop/projekt/algorytmy optymalizacyjne/Firefly(alg.swietlikow).R')
source('C:/Users/Konasz/Desktop/projekt/testy/GSO funkcje.R')
n <- 50
m.l <- 50
w <- 0.95
c1 <- 0.2
c2 <- 0.2
xmin <- c(-32, -32)
xmax <- c(32, 32)
vmax <- c(4, 4)
psoptim(FUN=ackley.pso, n=n, max.loop=m.l, w=w, c1=c1, c2=c2,
xmin=xmin, xmax=xmax, vmax=vmax, seed=5)
