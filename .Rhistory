time.taken <- end.time - start.time
time.taken
start.time <- Sys.time()
psoptim(FUN=ackleypso, n=n, max.loop=m.l, w=w, c1=c1, c2=c2,
xmin=xmin, xmax=xmax, vmax=vmax, seed=5)
time.taken <- end.time - start.time
time.taken
start.time <- Sys.time()
psoptim(FUN=ackleypso, n=n, max.loop=m.l, w=w, c1=c1, c2=c2,
xmin=xmin, xmax=xmax, vmax=vmax, seed=5)
time.taken <- endtime - start.time
time.taken
start.time <- Sys.time()
###### instrukcje
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken
start.time <- Sys.time()
###### instrukcje
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken
start.time <- Sys.time()
###### instrukcje
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken
start.time <- Sys.time()
###### instrukcje
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken
start.time <- Sys.time()
###### instrukcje
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken
start.time <- Sys.time()
###### instrukcje
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken
start.time <- Sys.time()
###### instrukcje
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken
start.time <- Sys.time()
###### instrukcje
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken
start.time <- Sys.time()
n <- 50
m.l <- 50
w <- 0.95
c1 <- 0.2
c2 <- 0.2
xmin <- c(-32, -32)
xmax <- c(32, 32)
vmax <- c(4, 4)
endtime <- Sys.time()
time.taken <- endtime - start.time
time.taken
n <- 50
m.l <- 50
w <- 0.95
c1 <- 0.2
c2 <- 0.2
xmin <- c(-32, -32)
xmax <- c(32, 32)
vmax <- c(4, 4)
start.time <- Sys.time()
psoptim(FUN=ackleypso, n=n, max.loop=m.l, w=w, c1=c1, c2=c2,
xmin=xmin, xmax=xmax, vmax=vmax, seed=5,anim=false)
endtime <- Sys.time()
time.taken <- endtime - start.time
time.taken
n <- 50
m.l <- 50
w <- 0.95
c1 <- 0.2
c2 <- 0.2
xmin <- c(-32, -32)
xmax <- c(32, 32)
vmax <- c(4, 4)
start.time <- Sys.time()
psoptim(FUN=ackleypso, n=n, max.loop=m.l, w=w, c1=c1, c2=c2,
xmin=xmin, xmax=xmax, vmax=vmax, seed=5,anim=FALSE)
endtime <- Sys.time()
time.taken <- endtime - start.time
time.taken
x = matrix(0,,2)
x[1,1] = 5
x[1,2] = 4
ackley1(x)
ackley <- function(xx, a=20, b=0.2, c=2*pi)
{
##########################################################################
#
# ACKLEY FUNCTION
#
# Authors: Sonja Surjanovic, Simon Fraser University
#          Derek Bingham, Simon Fraser University
# Questions/Comments: Please email Derek Bingham at dbingham@stat.sfu.ca.
#
# Copyright 2013. Derek Bingham, Simon Fraser University.
#
# THERE IS NO WARRANTY, EXPRESS OR IMPLIED. WE DO NOT ASSUME ANY LIABILITY
# FOR THE USE OF THIS SOFTWARE.  If software is modified to produce
# derivative works, such modified software should be clearly marked.
# Additionally, this program is free software; you can redistribute it
# and/or modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation; version 2.0 of the License.
# Accordingly, this program is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty
# of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# For function details and reference information, see:
# http://www.sfu.ca/~ssurjano/
#
##########################################################################
#
# INPUTS:
#
# xx = c(x1, x2, ..., xd)
# a = constant (optional), with default value 20
# b = constant (optional), with default value 0.2
# c = constant (optional), with default value 2*pi
#
##########################################################################
d <- length(xx)
sum1 <- sum(xx^2)
sum2 <- sum(cos(c*xx))
term1 <- -a * exp(-b*sqrt(sum1/d))
term2 <- -exp(sum2/d)
y <- term1 + term2 + a + exp(1)
return(y)
}
ackley(x)
psoptim <- function(FUN, n=100, max.loop=100, w=.9, c1=.2, c2=.2, xmin, xmax, vmax=c(4,4), seed=10, anim=TRUE)
{
#FUN - nazwa optymalizowanej funkcji, funkcja musi byc jednoargumentowa
#co oznacza ze argumentem jest wektor
# n - liczba czastek w roju
# max.loop - maksymalna liczba iteracji
# w - wspolczynnik bezwladnosci
# c1 - wspolczynnik wlasnego "zaufania"
# c2 - wspolczynnik "zaufania" do roju
# xmin - wektor okreslajacy dolne ograniczenia wartosci zmiennych
# xmax - wektor okreslajacy gorne ograniczenia wartosci zmiennych
# vmax - wektor ograniczen predkosci w kazdym kierunku
# seed - liczba naturalna okreslajaca tzw. ziarno dla generatora liczb
#pseudolosowych argument stosowany w celu uzyskania powtarzalnosci otrzymywanych wynikow
# anim - wartosc logiczna, jesli prawda TRUE(wartosc domyslna), to animacja przebiegu
# optymalizajci jest wlaczona
g1 <- function(x,y)
{
FUN(cbind(x,y))
}
d <- length(xmin)
set.seed(seed)
x <- matrix(nrow=n, ncol=d)
for(i in 1:d)
x[,i] <- runif(n, xmin[1],xmax[1])
wart.f <- FUN(x)
x.best.czastki <- x
x.best.roju <- matrix(x[which.max(wart.f),], ncol=d)
if((d == 2) && anim)
{
x_image <- matrix(c(seq(from=xmin[1],to=xmax[1],length.out=100),seq(from=xmin[2],to=xmax[2],length.out=100)), ncol=2)
z <- outer(x_image[,1], x_image[,2], g1)
image(x_image[,1], x_image[,2], z, xlab="x1", ylab="x2", main="Initial swarm")
contour(x_image[,1], x_image[,2], z, nlevels=10, add=TRUE, col="grey50")
points(x[,1], x[,2], pch=19, col="darkslateblue")
}
if (interactive() && anim && (d==2)) {
invisible(readline(prompt = "Press <Enter>/<Return> to continue..."))
}
v <- matrix(runif(n*d, min=-vmax, max=vmax), ncol=d, nrow=n)
g.mean <- c()
g.best <- c()
loop <- 1
while(loop <= max.loop)
{
wart.f <- FUN(x)
g.mean <- rbind(g.mean, mean(wart.f))
idx <- which(wart.f > FUN(x.best.czastki))
x.best.czastki[idx,] <- x[idx,]
x.best.roju.nowe <- matrix(x[which.max(FUN(x.best.czastki)),],ncol=d)
if(FUN(x.best.roju.nowe) > FUN(x.best.roju))
x.best.roju <- x.best.roju.nowe
g.best <- rbind(g.best, FUN(x.best.roju))
for(i in 1:n)
{
for(j in 1:d)
{
r1 <- runif(1)
r2 <- runif(1)
v[i,j] <- w*v[i,j] + c1*r1*(x.best.czastki[i,j] - x[i,j]) +  c2*r2*(x.best.roju[j]-x[i,j])
if(v[i,j] > vmax[j] || v[i,j] < -vmax[j])
v[i,j] <- vmax[j]
x_prev <- x[i,j]
x[i,j] <- x[i,j] + v[i,j]
if(x[i,j] > xmax[j])
x[i,j] <- x_prev
if(x[i,j] < xmin[j])
x[i,j] <- x_prev
}
}
if((d==2) && anim)
{
contour(x_image[,1], x_image[,2], z, nlevels=20, xlab="x1", ylab="x2", col="darkgray", main=paste(loop, "/", max.loop))
points(x, xlim=c(xmin[1], xmax[1]), ylim=c(xmin[2], xmax[2]), pch=21, bg="cadetblue")
# points(x, xlim=c(xmin[1], xmax[1]), ylim=c(xmin[2], xmax[2]), pch=21, bg=densCols(x))
}
loop <- loop + 1
}
if(anim)
{
if (interactive() & (d==2)) {
invisible(readline(prompt = "Press <Enter>/<Return> to continue..."))
}
}
plot(g.best, type="o", col="darkgreen", pch=19, cex=.7, ylim=c(min(g.mean),max(g.best)), xlab="Iteration", ylab="Fitness value")
lines(g.mean, type="o", col="blue", cex=.7, pch=19)
legend("bottomright", legend = c("Best", "Mean"), col = c("darkgreen", "blue"), pch = 19, lty = 1, merge = TRUE)
colnames(x.best.roju) <- paste("x", seq(1:d), sep="")
res <- list(sol = x.best.roju, val=g.best[loop-1])
return(res)
}
ackleypso = function(x)
{
a =-20*exp(-0.2*sqrt(0.5*(x[,1]^2+x[,2]^2)))-exp(0.5*(cos(2*pi*x[,1])+cos(2*pi*x[,2]))) + exp(1) + 20
return(a)
}
x = matrix(0,,2)
x[1,1] = 5
x[1,2] = 4
ackley1(x)
ackleypso = function(x)
{
a =-20*exp(-0.2*sqrt(0.5*(x[,1]^2+x[,2]^2)))-exp(0.5*(cos(2*pi*x[,1])+cos(2*pi*x[,2]))) + exp(1) + 20
return(a)
}
n <- 50
m.l <- 50
w <- 0.95
c1 <- 0.2
c2 <- 0.2
xmin <- c(-32, -32)
xmax <- c(32, 32)
vmax <- c(4, 4)
start.time <- Sys.time()#czas trzeba mierzyc z anim=FALSE
psoptim(FUN=ackleypso, n=n, max.loop=m.l, w=w, c1=c1, c2=c2,
xmin=xmin, xmax=xmax, vmax=vmax, seed=5,anim=false)
endtime <- Sys.time()
time.taken <- endtime - start.time
time.taken
n <- 50
m.l <- 50
w <- 0.95
c1 <- 0.2
c2 <- 0.2
xmin <- c(-32, -32)
xmax <- c(32, 32)
vmax <- c(4, 4)
start.time <- Sys.time()#czas trzeba mierzyc z anim=FALSE
psoptim(FUN=ackleypso, n=n, max.loop=m.l, w=w, c1=c1, c2=c2,
xmin=xmin, xmax=xmax, vmax=vmax, seed=5,anim=FALSE)
endtime <- Sys.time()
time.taken <- endtime - start.time
time.taken
n <- 50
m.l <- 50
w <- 0.95
c1 <- 0.2
c2 <- 0.2
xmin <- c(-32, -32)
xmax <- c(32, 32)
vmax <- c(4, 4)
start.time <- Sys.time()#czas trzeba mierzyc z anim=FALSE
psoptim(FUN=-ackleypso, n=n, max.loop=m.l, w=w, c1=c1, c2=c2,
xmin=xmin, xmax=xmax, vmax=vmax, seed=5,anim=FALSE)
endtime <- Sys.time()
time.taken <- endtime - start.time
time.taken
ackleypso = function(x)
{
a =-(-20*exp(-0.2*sqrt(0.5*(x[,1]^2+x[,2]^2)))-exp(0.5*(cos(2*pi*x[,1])+cos(2*pi*x[,2]))) + exp(1) + 20)
return(a)
}
x = matrix(0,,2)
x[1,1] = 5
x[1,2] = 4
ackleypso(x)
ackley <- function(xx, a=20, b=0.2, c=2*pi)
{
##########################################################################
#
# ACKLEY FUNCTION
#
# Authors: Sonja Surjanovic, Simon Fraser University
#          Derek Bingham, Simon Fraser University
# Questions/Comments: Please email Derek Bingham at dbingham@stat.sfu.ca.
#
# Copyright 2013. Derek Bingham, Simon Fraser University.
#
# THERE IS NO WARRANTY, EXPRESS OR IMPLIED. WE DO NOT ASSUME ANY LIABILITY
# FOR THE USE OF THIS SOFTWARE.  If software is modified to produce
# derivative works, such modified software should be clearly marked.
# Additionally, this program is free software; you can redistribute it
# and/or modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation; version 2.0 of the License.
# Accordingly, this program is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty
# of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# For function details and reference information, see:
# http://www.sfu.ca/~ssurjano/
#
##########################################################################
#
# INPUTS:
#
# xx = c(x1, x2, ..., xd)
# a = constant (optional), with default value 20
# b = constant (optional), with default value 0.2
# c = constant (optional), with default value 2*pi
#
##########################################################################
d <- length(xx)
sum1 <- sum(xx^2)
sum2 <- sum(cos(c*xx))
term1 <- -a * exp(-b*sqrt(sum1/d))
term2 <- -exp(sum2/d)
y <- term1 + term2 + a + exp(1)
return(y)
}
ackley(5,4)
ackleyga = function(x1,x2)
{
a =-20*exp(-0.2*sqrt(0.5*(x1^2+x2^2)))-exp(0.5*(cos(2*pi*x1)+cos(2*pi*x2))) + exp(1) + 20
return(a)
}
ackleyga(5,4)
n <- 50
m.l <- 50
w <- 0.95
c1 <- 0.2
c2 <- 0.2
xmin <- c(-32, -32)
xmax <- c(32, 32)
vmax <- c(4, 4)
start.time <- Sys.time()#czas trzeba mierzyc z anim=FALSE
psoptim(FUN=ackleypso, n=n, max.loop=m.l, w=w, c1=c1, c2=c2,
xmin=xmin, xmax=xmax, vmax=vmax, seed=5,anim=FALSE)
endtime <- Sys.time()
time.taken <- endtime - start.time
time.taken
ackleyga(-0.0212,-0.090)
ackleyga(-0.0000212,-0.0000090)
n <- 100
m.l <- 100
w <- 0.95
c1 <- 0.2
c2 <- 0.2
xmin <- c(-32, -32)
xmax <- c(32, 32)
vmax <- c(4, 4)
start.time <- Sys.time()#czas trzeba mierzyc z anim=FALSE
psoptim(FUN=ackleypso, n=n, max.loop=m.l, w=w, c1=c1, c2=c2,
xmin=xmin, xmax=xmax, vmax=vmax, seed=5,anim=FALSE)
endtime <- Sys.time()
time.taken <- endtime - start.time
time.taken
ackleyabc = function(x)
{
a =-20*exp(-0.2*sqrt(0.5*(x[1]^2+x[2]^2)))-exp(0.5*(cos(2*pi*x[1])+cos(2*pi*x[2]))) + exp(1) + 20
return(a)
}
ackleyabc(5,4)
x=c(5,4)
ackleyabc(x)
x=c(1,2)
ackleyabc(x)
library(ABCoptim)
q=matrix(1,2,2)
q
q=matrix(1,,2)
q
q=matrix(1,1,2)
q
x = matrix(0,,2)
x[1,1] = 5
x[1,2] = 4
ackleypso(x)
x = matrix(0,,2)
x
x[1,1] = 5
x
x[,2] = 4
x
x = matrix(0,1,2)
x
fun <- ackleyabc
ans0 <- abc_optim(rep(0,2), fun, lb=-32, ub=32, criter=50)
ans0[c("par", "counts", "value")]
ans1 <- abc_cpp(rep(0,2), fun, lb=-32, ub=32, criter=50)
ans1[c("par", "counts", "value")]
plot(ans1)
fun <- function(x) {
-cos(x[1])*cos(x[2])*exp(-((x[1] - pi)^2 + (x[2] - pi)^2))
}
ans0 <- abc_optim(rep(0,2), fun, lb=-10, ub=10, criter=50)
ans0[c("par", "counts", "value")]
ans1 <- abc_cpp(rep(0,2), fun, lb=-10, ub=10, criter=50)
ans1[c("par", "counts", "value")]
fun <- ackleyabc
ans0 <- abc_optim(rep(0,2), fun, lb=-10, ub=10, criter=50)
ans0[c("par", "counts", "value")]
ans1 <- abc_cpp(rep(0,2), fun, lb=-10, ub=10, criter=50)
ans1[c("par", "counts", "value")]
fw <- function (x)
10*sin(0.3*x)*sin(1.3*x^2) + 0.00001*x^4 + 0.2*x+80
ans <- abc_optim(50, fw, lb=-100, ub=100, criter=100)
ans[c("par", "counts", "value")]
# EXAMPLE 3: 5D sphere, global minimum at about (0,0,0,0,0)
fs <- function(x) sum(x^2)
ackleyabc = function(x)
{
a =-(-20*exp(-0.2*sqrt(0.5*(x[1]^2+x[2]^2)))-exp(0.5*(cos(2*pi*x[1])+cos(2*pi*x[2]))) + exp(1) + 20)
return(a)
}
fun <- ackleyabc
ans0 <- abc_optim(rep(0,2), fun, lb=-10, ub=10, criter=50)
ans0[c("par", "counts", "value")]
ans1 <- abc_cpp(rep(0,2), fun, lb=-10, ub=10, criter=50)
ans1[c("par", "counts", "value")]
GA:
ackleyga = function(x1,x2)
{
a =-20*exp(-0.2*sqrt(0.5*(x1^2+x2^2)))-exp(0.5*(cos(2*pi*x1)+cos(2*pi*x2))) + exp(1) + 20
return(a)
}
ackleyga = function(x1,x2)
{
a =-20*exp(-0.2*sqrt(0.5*(x1^2+x2^2)))-exp(0.5*(cos(2*pi*x1)+cos(2*pi*x2))) + exp(1) + 20
return(a)
}
clear
clear()
x = matrix(,,2)
x
ackleyga(9.54,9.54)
fun <- ackleyabc
ans0 <- abc_optim(rep(0,2), fun, lb=-32, ub=32, criter=50)
ans0[c("par", "counts", "value")]
ans1 <- abc_cpp(rep(0,2), fun, lb=-32, ub=32, criter=50)
ans1[c("par", "counts", "value")]
fun <- ackleyabc
ans0 <- abc_optim(rep(0,2), fun, lb=-32, ub=32, criter=50)
ans0[c("par", "counts", "value")]
ans1 <- abc_cpp(rep(0,2), fun, lb=-32, ub=32, criter=50)
ans1[c("par", "counts", "value")]
plot(ans0)
fun <- ackleyabc
ans0 <- abc_optim(rep(0,2), fun, lb=-32, ub=32, criter=50)
ans0[c("par", "counts", "value")]
ans1 <- abc_cpp(rep(0,2), fun, lb=-32, ub=32, criter=50)
ans1[c("par", "counts", "value")]
plot(abc_optim)
ackleyabc = function(x)
{
a =-20*exp(-0.2*sqrt(0.5*(x[1]^2+x[2]^2)))-exp(0.5*(cos(2*pi*x[1])+cos(2*pi*x[2]))) + exp(1) + 20
return(a)
}
fun <- ackleyabc
ans0 <- abc_optim(rep(0,2), fun, lb=-32, ub=32, criter=50)
ans0[c("par", "counts", "value")]
ans1 <- abc_cpp(rep(0,2), fun, lb=-32, ub=32, criter=50)
ans1[c("par", "counts", "value")]
fun <- ackleyabc
ans0 <- abc_optim(rep(0,2), fun, lb=-32, ub=32, criter=50)
ans0[c("par", "counts", "value")]
fun <- ackleyabc
start.time <- Sys.time()
ans0 <- abc_optim(rep(0,2), fun, lb=-32, ub=32, criter=50)
ans0[c("par", "counts", "value")]
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken
x = c(3,6,7)
x[5]
x[2]
x
ackleyabc = function(x)
{
a =-(-20*exp(-0.2*sqrt(0.5*(x[1]^2+x[2]^2)))-exp(0.5*(cos(2*pi*x[1])+cos(2*pi*x[2]))) + exp(1) + 20)
return(a)
}
fun <- ackleyabc
start.time <- Sys.time()
ans0 <- abc_optim(rep(0,2), fun, lb=-32, ub=32, criter=50)
ans0[c("par", "counts", "value")]
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken
sum(4+3)(5+6)
sum((4+3)(5+6))
