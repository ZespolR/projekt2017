0.25*x1^4 - 0.5*x1^2 + 0.1*x1 + 0.5*x2^2
}
GSO:
ackley.gso = function(x,y)
{
a =-(-20*exp(-0.2*sqrt(0.5*(x^2+y^2)))-exp(0.5*(cos(2*pi*x)+cos(2*pi*y))) + exp(1) + 20)
return(a)
}
rastrigin.gso <- function(x,y) # x[-5.12,5.12] min 0 at (0,0)
-(20 + x^2 + y^2 - 10*(cos(2*pi*x) + cos(2*pi*y)))
beale.gso = function(x,y) # [-4.5,4.5] min 0 at (3,0.5)
-((1.5-x+x*y)^2 + (2.25-x+x*y^2)^2 +(2.625-x+x*y^3)^2)
goldstein.gso = function(x,y) # [-2,2] min 3 at (0,-1)
-((1+(x+y+1)^2 * (19-14*x+3*x^2 - 14*y+6*x*y+3*y^2))*(30+(2*x-3*y)^2 * (18-32*x+12*x^2 + 48*y-36*x*y+27*y^2)))
booth.gso = function(x,y) # [-10,10] min 0 at (1,3)
-((x+ 2*y-7)^2 + (2*x+y-5)^2)
bukin.gso = function(x,y) # x1[-15,-5] x2[-3,3] min 0 at (-10,1)
-(100*sqrt(abs(y-0.01*x^2))+0.01*abs(x+10))
matyas.gso = function(x,y) # [-10,10] min 0 at (0,0)
-(0.26*(x^2+y^2)-0.48*x*y)
levin13.gso = function(x,y) # [-10,10] min 0 at (1,1)
-(sin(3*pi*x)^2+(x-1)^2 * (1+sin(3*pi*y)^2)+(y-1)^2 * (1+sin(2*pi*y)^2))
three.hump.camel.gso = function(x,y) # [-5,5] min 0 at (0,0)
-(2*x^2 - 1.05*x^4 + (x^6)/6 + x*y + y^2)
easom.gso = function(x,y) # [-100,100] min -1 at (3.14,3.14)
-(-cos(x)*cos(y)*exp(-((x-pi)^2 + (y-pi)^2)))
schaffer.gso = function(x,y) # [-100,100] min 0 at (0,0)
-(0.5+(sin(x^2 - y^2)^2 - 0.5)/(1+0.001*(x^2 + y^2))^2)
eggholder.gso = function(x,y) # [-512,512] min -959 at (512,404)
-(-(y+47)*sin(sqrt(abs(y+x/2+47)))-x*sin(sqrt(abs(x-(y+47)))))
six.hump.camel.gso <- function(x,y) #x1[-3,3] x2[-2,2] min -1.03 at (0.089,-0.712) lub(-0.089,   0.71)
-((4-2.1*x^2+(x^4)/3)*x^2+x*y+(-4+4*y^2)*y^2)
gramacy_lee.gso = function(x,y) ## 1 wymiarowe [0.5,2.5]
-((((sin(10*pi*x))/(2*x))+(x-1)^4))
drop_wave.gso = function(x,y)# [-5.12,5.12] min -1 at (0,0)
-((-(1+cos(12*sqrt(x^2+y^2)))/(0.5*(x^2+y^2)+2)))
mccormick.gso = function(x,y) # x1[-1.5,4] x2[-3,4] min -1.91 at (-0.54,-1.54)
-(sin(x+y)+(x-y)^2-(1.5*x)+(2.5*y)+1)
holder.table.gso <- function(x,y) #x[-10,10] min -19 at (8.05,9.66 i z minusami)
-(-abs(sin(x)*cos(y)*exp(abs(1 - sqrt(x^2+y^2)/pi))))
cross_in_tray.gso = function(x,y) # x[-10,10] min -2.06 at (1.34,1.34 i z minusami)
-(-0.0001*(abs(sin(x)*sin(y)*exp(abs(100-((sqrt(x^2+y^2))/pi))))+1)^0.1)
test_tube_1.gso = function(x,y) ## nie ze strony
-(-4*abs(sin(x)*cos(y)*exp(1)^abs(cos(((x^2)+(y^2))/200))))
adjiman.gso = function(x,y) # x1[-1,2] x2[-1,1] min -2.02 at (2,0.1)
-(cos(x)*sin(y) - (x)/(y^2 +1))
bartels.conn.gso = function(x,y) # [-500,500] min 1 at (0,0)
-(abs(x^2 + y^2 + x*y)+abs(sin(x))+abs(cos(y)))
bohachevsky.gso = function(x,y) # [-100,100] min 0 at (0,0)
-(x^2 + 2*y^2 - 0.3*cos(3*pi*x) - 0.4*cos(4*pi*y)+0.7)
brent.gso = function(x,y) #[-10,10] min 0 at (0,0) ale wychodzi 201
-((x+10)^2 + (y+10)^2 + exp(1)^(-x^2 -y^2))
leon.gso = function(x,y) # [-1.2,1.2] min 0 at (1,1)
-(100*(y-x^2)^2 + (1-x)^2)
venter.gso = function(x,y) # [-50,50] min -400 at (0,0)
-(x^2 - 100*cos(x)^2-100*cos(x^2/30)+y^2-100*cos(y)^2-100*cos(y^2/30))
zirilli.gso = function(x,y) #[-10,10] min -0.35 at (-1.04,0)
-(0.25*x^4 - 0.5*x^2 + 0.1*x + 0.5*y^2)
Bat:
ackley.bat = function(D, sol)
{
a=20
b=0.2
c=2*pi
xx = sol
sum1 <- sum(xx^2)
sum2 <- sum(cos(c*xx))
term1 <- -a * exp(-b*sqrt(sum1/D))
term2 <- -exp(sum2/D)
y <- term1 + term2 + a + exp(1)
return(y)
}
rastrigin.bat <- function(D,x) # x[-5.12,5.12] min 0
{
x1 <- x[1]
x2 <- x[2]
20 + x1^2 + x2^2 - 10*(cos(2*pi*x1) + cos(2*pi*x2))
}
beale.bat = function(D,x) # [-4.5,4.5] min 0 at (3,0.5)
{
x1 <- x[1]
x2 <- x[2]
(1.5-x1+x1*x2)^2 + (2.25-x1+x1*x2^2)^2 +(2.625-x1+x1*x2^3)^2
}
goldstein.bat = function(D,x) # [-2,2] min 3 at (0,-1)
{
x1 <- x[1]
x2 <- x[2]
(1+(x1+x2+1)^2 * (19-14*x1+3*x1^2 - 14*x2+6*x1*x2+3*x2^2))*(30+(2*x1-3*x2)^2 * (18-32*x1+12*x1^2 + 48*x2-36*x1*x2+27*x2^2))
}
booth.bat = function(D,x) # [-10,10] min 0 at (1,3)
{
x1 <- x[1]
x2 <- x[2]
(x1+ 2*x2-7)^2 + (2*x1+x2-5)^2
}
bukin.bat = function(D,x) # x1[-15,-5] x2[-3,3] min 0 at (-10,1)
{
x1 <- x[1]
x2 <- x[2]
100*sqrt(abs(x2-0.01*x1^2))+0.01*abs(x1+10)
}
matyas.bat = function(D,x) # [-10,10] min 0 at (0,0)
{
x1 <- x[1]
x2 <- x[2]
0.26*(x1^2+x2^2)-0.48*x1*x2
}
levin13.bat = function(D,x) # [-10,10] min 0 at (1,1)
{
x1 <- x[1]
x2 <- x[2]
sin(3*pi*x1)^2+(x1-1)^2 * (1+sin(3*pi*x2)^2)+(x2-1)^2 * (1+sin(2*pi*x2)^2)
}
three.hump.camel.bat = function(D,x) # [-5,5] min 0 at (0,0)
{
x1 <- x[1]
x2 <- x[2]
2*x1^2 - 1.05*x1^4 + (x1^6)/6 + x1*x2 + x2^2
}
easom.bat = function(D,x) # [-100,100] min -1 at (3.14,3.14)
{
x1 <- x[1]
x2 <- x[2]
-cos(x1)*cos(x2)*exp(-((x1-pi)^2 + (x2-pi)^2))
}
schaffer.bat = function(D,x) # [-100,100] min 0 at (0,0)
{
x1 <- x[1]
x2 <- x[2]
0.5+(sin(x1^2 - x2^2)^2 - 0.5)/(1+0.001*(x1^2 + x2^2))^2
}
eggholder.bat = function(D,x) # [-512,512] min -959 at (512,404)
{
x1 <- x[1]
x2 <- x[2]
-(x2+47)*sin(sqrt(abs(x2+x1/2+47)))-x1*sin(sqrt(abs(x1-(x2+47))))
}
six.hump.camel.bat <- function(D,x) #x1[-3,3] x2[-2,2] min -1.03 at (0.089,-0.712) lub(-0.089,   0.71)
{
x1 <- x[1]
x2 <- x[2]
(4-2.1*x1^2+(x1^4)/3)*x1^2+x1*x2+(-4+4*x2^2)*x2^2
}
gramacy_lee.bat = function(D,x) ## 1 wymiarowe [0.5,2.5]
{
x1 <- x[1]
x2 <- x[2]
(((sin(10*pi*x1))/(2*x1))+(x1-1)^4)
}
drop_wave.bat = function(D,x)# [-5.12,5.12] min -1 at (0,0)
{
x1 <- x[1]
x2 <- x[2]
(-(1+cos(12*sqrt(x1^2+x2^2)))/(0.5*(x1^2+x2^2)+2))
}
mccormick.bat = function(D,x) # x1[-1.5,4] x2[-3,4] min -1.91 at (-0.54,-1.54)
{
x1 <- x[1]
x2 <- x[2]
sin(x1+x2)+(x1-x2)^2-(1.5*x1)+(2.5*x2)+1
}
holder.table.bat <- function(D,x) #x[-10,10] min -19 at (8.05,9.66 i z minusami)
{
x1 <- x[1]
x2 <- x[2]
-abs(sin(x1)*cos(x2)*exp(abs(1 - sqrt(x1^2+x2^2)/pi)))
}
cross_in_tray.bat = function(D,x) # x[-10,10] min -2.06 at (1.34,1.34 i z minusami)
{
x1 <- x[1]
x2 <- x[2]
-0.0001*(abs(sin(x1)*sin(x2)*exp(abs(100-((sqrt(x1^2+x2^2))/pi))))+1)^0.1
}
test_tube_1.bat = function(D,x) ## nie ze strony
{
x1 <- x[1]
x2 <- x[2]
-4*abs(sin(x1)*cos(x2)*exp(1)^abs(cos(((x1^2)+(x2^2))/200)))
}
adjiman.bat = function(D,x) # x1[-1,2] x2[-1,1] min -2.02 at (2,0.1)
{
x1 <- x[1]
x2 <- x[2]
cos(x1)*sin(x2) - (x1)/(x2^2 +1)
}
bartels.conn.bat = function(D,x) # [-500,500] min 1 at (0,0)
{
x1 <- x[1]
x2 <- x[2]
abs(x1^2 + x2^2 + x1*x2)+abs(sin(x1))+abs(cos(x2))
}
bohachevsky.bat = function(D,x) # [-100,100] min 0 at (0,0)
{
x1 <- x[1]
x2 <- x[2]
x1^2 + 2*x2^2 - 0.3*cos(3*pi*x1) - 0.4*cos(4*pi*x2)+0.7
}
brent.bat = function(D,x) #[-10,10] min 0 at (0,0) ale wychodzi 201
{
x1 <- x[1]
x2 <- x[2]
(x1+10)^2 + (x2+10)^2 + exp(1)^(-x1^2 -x2^2)
}
leon.bat = function(D,x) # [-1.2,1.2] min 0 at (1,1)
{
x1 <- x[1]
x2 <- x[2]
100*(x2-x1^2)^2 + (1-x1)^2
}
venter.bat = function(D,x) # [-50,50] min -400 at (0,0)
{
x1 <- x[1]
x2 <- x[2]
x1^2 - 100*cos(x1)^2-100*cos(x1^2/30)+x2^2-100*cos(x2)^2-100*cos(x2^2/30)
}
zirilli.bat = function(D,x) #[-10,10] min -0.35 at (-1.04,0)
{
x1 <- x[1]
x2 <- x[2]
0.25*x1^4 - 0.5*x1^2 + 0.1*x1 + 0.5*x2^2
}
#Algorytm domyślnie liczy maksimum funkcji wiec trzeba funkcje pomnozyc *-1
funkcja = ackley.gso #przykladowo
zakres <- c(-5.12,5.12) # zakres
para <- c(100,20,0.25,0.20,1) #no_firefly,N_iteration,alpha, betamin, gamma
start.time <- Sys.time()
firefly_algo(no_firefly,N_iteration,alpha, betamin, gamma,rng=zakres,FunA=funkcja)
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken
ackley.gso = function(x,y)
{
a =-(-20*exp(-0.2*sqrt(0.5*(x^2+y^2)))-exp(0.5*(cos(2*pi*x)+cos(2*pi*y))) + exp(1) + 20)
return(a)
}
#Algorytm domyślnie liczy maksimum funkcji wiec trzeba funkcje pomnozyc *-1
funkcja = ackley.gso #przykladowo
zakres <- c(-5.12,5.12) # zakres
para <- c(100,20,0.25,0.20,1) #no_firefly,N_iteration,alpha, betamin, gamma
start.time <- Sys.time()
firefly_algo(no_firefly,N_iteration,alpha, betamin, gamma,rng=zakres,FunA=funkcja)
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken
#Reference Paper: Xin-She Yang, Nature-Inspired Metaheuristic Algorithms (second edition), pg 81-89, Luniver Press-2010
#You can either give your own input while running Firefly_algo in the bottom of this page or can leave default
#Inputs: no_firefly (total number of fireflies), N_iteration (number of timesteps),alpha (Randomness),betmin (Minimum value of beta (the attractiveness parameter)),gamma(Absorption coefficient), rng (minumum and maximum value), Fun (desired function to optimize)
firefly_algo <- function (no_firefly,N_iteration,alpha, betamin, gamma,rng,FunA){
no_firefly <- para[1]
MaxGeneration <- para[2]
alpha <- para[3]
betamin <- para[4]
gamma <- para[5]
#Generate the initial locations of n fireflies
init_ffa <- function (no_firefly,rng){
ak<-rng[2] - rng[1]
x1n <- t(matrix(runif(no_firefly)*ak + rng[1]))
x2n <- t(matrix(runif(no_firefly)*ak + rng[1]))
Lightn <-matrix (0,nrow(x1n),ncol(x1n))
return(list(x1n,x2n,Lightn))		#initial value before function evaluations
}
#Make sure the fireflies are within the range
findrange_r <- function (x1n,x2n, rng){
for (i in 1: length(x1n)){
if (x1n[i] <= rng[1]){
x1n[i] <- rng[1]
}
if (x1n[i] >= rng[2]){
x1n[i] <- rng[2]
}
if (x2n[i]<= rng[1]){
x2n[i] <-rng[1]
}
if (x2n[i] >= rng[2]){
x2n[i]=rng[2]
}
}
return (list(x1n,x2n))
}
#Move all fireflies to the better locations
ffa_move <-function (x1n,x2n,Lightn,x1o,x2o,Lighto,alpha,gamma,rng){
ni = length(x1n)
nj= length(x1o)
for (i in 1:ni){
for (j in 1:nj){
r = sqrt((x1n[i]-x1o[j])^2 + (x2n[i]-x2o[j])^2) # This is the euclidian distance but you can change it according to ur needs
if (Lightn[i]<Lighto[j]){
beta0 =1
#if you are not using betamin then beta <- beta0 * exp((-gamma) * r^2)
beta<-(beta0-betamin)* exp(-gamma * r^2)+ betamin
x1n[i] <- x1n[i]*(1-beta) + (x1o[j]*beta) +(alpha * (runif(1)-0.5)) # * exp(-0.2*log(downscale)))
x2n[i] <- x2n[i]*(1-beta)+ (x2o[j] * beta) + (alpha * (runif(1) -0.5))	# * exp(-0.2*log(downscale)))
}
}
}
fdr <- findrange_r(x1n,x2n,rng);
x1n <-fdr[[1]]
x2n <-fdr[[2]]
return (list(x1n,x2n))
}
## This function is optional, as it is not in the original FA. The idea to reduce randomness is to increase the convergence, however, if you reduce randomness too quickly, then premature convergence can occur. So use with care.
alpha_new<-function(alpha,NGen){
#alpha_n=alpha_0(1-delta)^NGen=0.005
#alpha_0=0.9
delta<-1-(0.005/0.9)^(1/NGen)
alpha<-(1-delta)*alpha
}
#Initial values of an array
zn <-rep((10^100),no_firefly)
As<-init_ffa(no_firefly,rng)
x1n <-As[[1]]
x2n <-As[[2]]
Lightn <-As[[3]]
for (i in 1:MaxGeneration){
alpha=alpha_new(alpha,MaxGeneration) # This is optional
prob <- c(0.8,0.2)
zn <-FunA(x1n,x2n)
# Ranking the fireflies by their light intensity
tmp<-sort(zn,index.return=TRUE)
Lightn<-tmp$x
idx<-tmp$ix  #idx is index
##Reordering of fireflies by their light intensity
x1n<-x1n[idx]
x2n=x2n[idx]
# initial value of xo, yo and Lighto is changed here
x1o<-x1n
x2o<-x2n
Lighto<-Lightn
# Move all fireflies to the better locations
plot(x1o,x2o,main="Pozycje świetlików",type = "p",pch=19,xlab="x1", ylab="x2",xlim=range(rng[1]:rng[2]),ylim=range(rng[1]:rng[2]))
#points(x, xlim=c(rng[1], rng[2]), ylim=c(rng[1], rng[2]), pch=21, bg="cadetblue")
tmp_move<- ffa_move(x1n,x2n,Lightn,x1o,x2o,Lighto,alpha,gamma,rng)
x1n <-tmp_move[[1]]
x2n <- tmp_move[[2]]
}
# Output
best <-cbind(x1n,x2n,Lightn)
plot(Lightn, type= "o",xlab="Iteracja", ylab="Wartość minimum")
return (best)
}
set.seed(5)
#Algorytm domyślnie liczy maksimum funkcji wiec trzeba funkcje pomnozyc *-1
funkcja = ackley.gso #przykladowo
zakres <- c(-5.12,5.12) # zakres
para <- c(100,20,0.25,0.20,1) #no_firefly,N_iteration,alpha, betamin, gamma
start.time <- Sys.time()
firefly_algo(no_firefly,N_iteration,alpha, betamin, gamma,rng=zakres,FunA=funkcja)
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken
#Reference Paper: Xin-She Yang, Nature-Inspired Metaheuristic Algorithms (second edition), pg 81-89, Luniver Press-2010
#You can either give your own input while running Firefly_algo in the bottom of this page or can leave default
#Inputs: no_firefly (total number of fireflies), N_iteration (number of timesteps),alpha (Randomness),betmin (Minimum value of beta (the attractiveness parameter)),gamma(Absorption coefficient), rng (minumum and maximum value), Fun (desired function to optimize)
firefly_algo <- function (no_firefly,N_iteration,alpha, betamin, gamma,rng,FunA){
no_firefly <- para[1]
MaxGeneration <- para[2]
alpha <- para[3]
betamin <- para[4]
gamma <- para[5]
#Generate the initial locations of n fireflies
init_ffa <- function (no_firefly,rng){
ak<-rng[2] - rng[1]
x1n <- t(matrix(runif(no_firefly)*ak + rng[1]))
x2n <- t(matrix(runif(no_firefly)*ak + rng[1]))
Lightn <-matrix (0,nrow(x1n),ncol(x1n))
return(list(x1n,x2n,Lightn))		#initial value before function evaluations
}
#Make sure the fireflies are within the range
findrange_r <- function (x1n,x2n, rng){
for (i in 1: length(x1n)){
if (x1n[i] <= rng[1]){
x1n[i] <- rng[1]
}
if (x1n[i] >= rng[2]){
x1n[i] <- rng[2]
}
if (x2n[i]<= rng[1]){
x2n[i] <-rng[1]
}
if (x2n[i] >= rng[2]){
x2n[i]=rng[2]
}
}
return (list(x1n,x2n))
}
#Move all fireflies to the better locations
ffa_move <-function (x1n,x2n,Lightn,x1o,x2o,Lighto,alpha,gamma,rng){
ni = length(x1n)
nj= length(x1o)
for (i in 1:ni){
for (j in 1:nj){
r = sqrt((x1n[i]-x1o[j])^2 + (x2n[i]-x2o[j])^2) # This is the euclidian distance but you can change it according to ur needs
if (Lightn[i]<Lighto[j]){
beta0 =1
#if you are not using betamin then beta <- beta0 * exp((-gamma) * r^2)
beta<-(beta0-betamin)* exp(-gamma * r^2)+ betamin
x1n[i] <- x1n[i]*(1-beta) + (x1o[j]*beta) +(alpha * (runif(1)-0.5)) # * exp(-0.2*log(downscale)))
x2n[i] <- x2n[i]*(1-beta)+ (x2o[j] * beta) + (alpha * (runif(1) -0.5))	# * exp(-0.2*log(downscale)))
}
}
}
fdr <- findrange_r(x1n,x2n,rng);
x1n <-fdr[[1]]
x2n <-fdr[[2]]
return (list(x1n,x2n))
}
## This function is optional, as it is not in the original FA. The idea to reduce randomness is to increase the convergence, however, if you reduce randomness too quickly, then premature convergence can occur. So use with care.
alpha_new<-function(alpha,NGen){
#alpha_n=alpha_0(1-delta)^NGen=0.005
#alpha_0=0.9
delta<-1-(0.005/0.9)^(1/NGen)
alpha<-(1-delta)*alpha
}
#Initial values of an array
zn <-rep((10^100),no_firefly)
As<-init_ffa(no_firefly,rng)
x1n <-As[[1]]
x2n <-As[[2]]
Lightn <-As[[3]]
for (i in 1:MaxGeneration){
alpha=alpha_new(alpha,MaxGeneration) # This is optional
prob <- c(0.8,0.2)
zn <-FunA(x1n,x2n)
# Ranking the fireflies by their light intensity
tmp<-sort(zn,index.return=TRUE)
Lightn<-tmp$x
idx<-tmp$ix  #idx is index
##Reordering of fireflies by their light intensity
x1n<-x1n[idx]
x2n=x2n[idx]
# initial value of xo, yo and Lighto is changed here
x1o<-x1n
x2o<-x2n
Lighto<-Lightn
# Move all fireflies to the better locations
plot(x1o,x2o,main="Pozycje świetlików",type = "p",pch=10,xlab="x1", ylab="x2",xlim=range(rng[1]:rng[2]),ylim=range(rng[1]:rng[2]))
#points(x, xlim=c(rng[1], rng[2]), ylim=c(rng[1], rng[2]), pch=21, bg="cadetblue")
tmp_move<- ffa_move(x1n,x2n,Lightn,x1o,x2o,Lighto,alpha,gamma,rng)
x1n <-tmp_move[[1]]
x2n <- tmp_move[[2]]
}
# Output
best <-cbind(x1n,x2n,Lightn)
plot(Lightn, type= "o",xlab="Iteracja", ylab="Wartość minimum")
return (best)
}
set.seed(5)
#Algorytm domyślnie liczy maksimum funkcji wiec trzeba funkcje pomnozyc *-1
funkcja = ackley.gso #przykladowo
zakres <- c(-5.12,5.12) # zakres
para <- c(100,20,0.25,0.20,1) #no_firefly,N_iteration,alpha, betamin, gamma
start.time <- Sys.time()
firefly_algo(no_firefly,N_iteration,alpha, betamin, gamma,rng=zakres,FunA=funkcja)
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken
plot(x1o,x2o,main="Pozycje świetlików",type = "p",pch=10,xlab="x1", ylab="x2",xlim=range(rng[1]:rng[2]),ylim=range(rng[1]:rng[2]))
source('C:/Users/Konasz/Desktop/projekt/algorytmy optymalizacyjne/Firefly(alg.swietlikow).R')
source('C:/Users/Konasz/Desktop/projekt/algorytmy optymalizacyjne/Firefly(alg.swietlikow).R')
#Algorytm domyślnie liczy maksimum funkcji wiec trzeba funkcje pomnozyc *-1
funkcja = ackley.gso #przykladowo
zakres <- c(-5.12,5.12) # zakres
para <- c(100,20,0.25,0.20,1) #no_firefly,N_iteration,alpha, betamin, gamma
start.time <- Sys.time()
firefly_algo(no_firefly,N_iteration,alpha, betamin, gamma,rng=zakres,FunA=funkcja)
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken
source('C:/Users/Konasz/Desktop/projekt/algorytmy optymalizacyjne/Firefly(alg.swietlikow).R')
#Algorytm domyślnie liczy maksimum funkcji wiec trzeba funkcje pomnozyc *-1
funkcja = ackley.gso #przykladowo
zakres <- c(-5.12,5.12) # zakres
para <- c(100,20,0.25,0.20,1) #no_firefly,N_iteration,alpha, betamin, gamma
start.time <- Sys.time()
firefly_algo(no_firefly,N_iteration,alpha, betamin, gamma,rng=zakres,FunA=funkcja)
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken
source('C:/Users/Konasz/Desktop/projekt/algorytmy optymalizacyjne/Firefly(alg.swietlikow).R')
#Algorytm domyślnie liczy maksimum funkcji wiec trzeba funkcje pomnozyc *-1
funkcja = ackley.gso #przykladowo
zakres <- c(-5.12,5.12) # zakres
para <- c(100,20,0.25,0.20,1) #no_firefly,N_iteration,alpha, betamin, gamma
start.time <- Sys.time()
firefly_algo(no_firefly,N_iteration,alpha, betamin, gamma,rng=zakres,FunA=funkcja)
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken
source('C:/Users/Konasz/Desktop/projekt/algorytmy optymalizacyjne/Firefly(alg.swietlikow).R')
#Algorytm domyślnie liczy maksimum funkcji wiec trzeba funkcje pomnozyc *-1
funkcja = ackley.gso #przykladowo
zakres <- c(-5.12,5.12) # zakres
para <- c(100,20,0.25,0.20,1) #no_firefly,N_iteration,alpha, betamin, gamma
start.time <- Sys.time()
firefly_algo(no_firefly,N_iteration,alpha, betamin, gamma,rng=zakres,FunA=funkcja)
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken
source('C:/Users/Konasz/Desktop/projekt/algorytmy optymalizacyjne/Firefly(alg.swietlikow).R')
source('C:/Users/Konasz/Desktop/projekt/algorytmy optymalizacyjne/Firefly(alg.swietlikow).R')
source('C:/Users/Konasz/Desktop/projekt/algorytmy optymalizacyjne/Firefly(alg.swietlikow).R')
source('C:/Users/Konasz/Desktop/projekt/algorytmy optymalizacyjne/Firefly(alg.swietlikow).R')
source('C:/Users/Konasz/Desktop/projekt/algorytmy optymalizacyjne/Firefly(alg.swietlikow).R')
source('C:/Users/Konasz/Desktop/projekt/algorytmy optymalizacyjne/Firefly(alg.swietlikow).R')
source('C:/Users/Konasz/Desktop/projekt/algorytmy optymalizacyjne/Firefly(alg.swietlikow).R')
x2n=x2n[idx]
source('C:/Users/Konasz/Desktop/projekt/algorytmy optymalizacyjne/Firefly(alg.swietlikow).R')
source('C:/Users/Konasz/Desktop/projekt/algorytmy optymalizacyjne/Firefly(alg.swietlikow).R')
source('C:/Users/Konasz/Desktop/projekt/algorytmy optymalizacyjne/Firefly(alg.swietlikow).R')
source('C:/Users/Konasz/Desktop/projekt/algorytmy optymalizacyjne/Firefly(alg.swietlikow).R')
source('C:/Users/Konasz/Desktop/projekt/algorytmy optymalizacyjne/Firefly(alg.swietlikow).R')
